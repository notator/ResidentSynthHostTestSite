/*
*  copyright 2015 James Ingram
*  https://james-ingram-act-two.de/
*
*  Code licensed under MIT
*
*  This file contains the implementation of the ResidentSynthHost's GUI. 
*/

var ResSynth = ResSynth || {};

ResSynth.host = (function(document)
{
    "use strict";

    var
        synth = null,
        inputDevice = null,
        currentChannel = 0,
        allLongInputControls = [], // used by AllControllersOff control
        channelPerKeyArrays = [], // initialized by getChannelPerKeyArrays(). This array has elements in range 0..15. Its length can be either 0 or 128.
        currentChannelPerKeyArray,
        globalChannelPressureType = "unused", // set by channelPressureSelect
        globalChannelPressureFactor = 0, // fraction set by channelPressureSensitivityLongControl
        presetRecordings = [], // the recordings in recordings.js, converted

        // set by startRecording(), undefined by stopRecording() or discardRecording()
        settingsBeforeRecording = undefined, // array of 16 currentSettings objects
        recordedMessages = undefined, // array of 16 messages arrays 

        // set by stopRecording(), undefined by saveRecording() or discardRecording()
        currentRecording = undefined,

        recordingChannelIndices = undefined, // initialized by onplayRecordingButtonInputClick(), reset by restoreStateAfterRecording()

        // used while playing back.
        cancelPlayback = false,
        recordingNoteOnError = false, // true if an attempt is made to record a NoteOn message into an existing recording.

        getElem = function(elemID)
        {
            return document.getElementById(elemID);
        },

        sendMessage = function(msg, channelIndex)
        {
            synth.send(msg);
            if(recordedMessages !== undefined)
            {
                let msPositionReRecording = performance.now();

                recordedMessages[channelIndex].push({msg, msPositionReRecording});
            }
        },

        throwError = function(errorString)
        {
            alert(errorString);
            throw errorString;
        },

        setOptions = function(select, options)
        {
            var i;

            for(i = select.options.length - 1; i >= 0; --i)
            {
                select.remove(i);
            }

            for(i = 0; i < options.length; ++i)
            {
                select.add(options[i]);
            }

            select.selectedIndex = 0;
        },

        sendLongControl = function(controlIndex, value)
        {
            let msg = new Uint8Array([ResSynth.constants.COMMAND.CONTROL_CHANGE + currentChannel, controlIndex, value]);
            sendMessage(msg, currentChannel);
        },

        sendShortControl = function(controlIndex)
        {
            function resetGUILongControllersAndSendButton()
            {
                let sendButtonInput = getElem("sendButtonInput");
                if(sendButtonInput.disabled === true)
                {
                    sendButtonInput.disabled = false;
                }

                for(let i = 0; i < allLongInputControls.length; ++i)
                {
                    let longInputControl = allLongInputControls[i];
                    longInputControl.setValue(longInputControl.numberInputElem.defaultValue);
                }
            }

            if(controlIndex === ResSynth.constants.CONTROL.ALL_CONTROLLERS_OFF)
            {
                resetGUILongControllersAndSendButton();
            }

            // controlIndex === ResSynth.constants.CONTROL.ALL_CONTROLLERS_OFF || controlIndex === ResSynth.constants.CONTROL.ALL_SOUND_OFF
            let msg = new Uint8Array([ResSynth.constants.COMMAND.CONTROL_CHANGE + currentChannel, controlIndex]);
            sendMessage(msg, currentChannel);
        },

        setInputDeviceEventListener = function(inputDeviceSelect)
        {
            function handleInputMessage(e)
            {
                // Rectify performed velocities so that they are in range [6..127].
                // The velocities generated by my E-MU keyboard are in range [20..127]
                // So: (deviceVelocity - 20) is in range [0..107],
                // ((deviceVelocity - 20) * 121 / 107) is in range [0..121],
                // (121 / 107) is ca. 1.1308
                // and (6 + Math.round(((deviceVelocity - 20) * 1.1308))) is in range [6..127]
                // (The E-MU keyboard's velocity response curve is set to its curve option number 5.)
                function getRectifiedEMUVelocity(deviceVelocity)
                {
                    let rectifiedVelocity = deviceVelocity; // can be 0 (E-MU sends 0 for NoteOff)
                    if(rectifiedVelocity >= 20)
                    {
                        rectifiedVelocity = 6 + Math.round((deviceVelocity - 20) * 1.1308);
                    }
                    console.log("emuVel=" + deviceVelocity.toString() + " vel=" + rectifiedVelocity.toString());

                    return rectifiedVelocity;
                }

                function updateGUI_ControlsTable(ccIndex, ccValue)
                {
                    let longInputControls = allLongInputControls.filter(elem => elem.numberInputElem.ccIndex === ccIndex);

                    // longInputControls.length will be > 1 if there is more than one control has no ccIndex.
                    // This function simply updates all the regParam controls even though only one of them has changed.
                    for(let i = 0; i < longInputControls.length; i++)
                    {
                        let longInputControl = longInputControls[i];

                        longInputControl.setValue(ccValue);
                    }
                }

                function updateGUI_CommandsTable(cmdIndex, cmdValue)
                {
                    let longInputControl = allLongInputControls.find(elem => elem.numberInputElem.cmdIndex === cmdIndex);

                    longInputControl.setValue(cmdValue);
                }

                function midiValue(arg)
                {
                    arg = (arg < 0) ? 0 : arg;
                    arg = (arg > 127) ? 127 : arg;
                    return arg;
                }

                let HOST_CMD_CHANNEL_PRESSURE = 0xD0,
                    CMD = ResSynth.constants.COMMAND,
                    data = e.data,
                    command = data[0] & 0xF0,
                    channel = (currentChannelPerKeyArray.length > 0) ? currentChannelPerKeyArray[data[1]] : data[0] & 0xF,
                    msg = new Uint8Array([((command + channel) & 0xFF), data[1], data[2]]);

                currentChannel = channel;

                switch(command)
                {
                    case CMD.NOTE_OFF:
                        break;
                    case CMD.NOTE_ON:
                        if(inputDevice.name.localeCompare("E-MU Xboard49") === 0)
                        {
                            msg[2] = getRectifiedEMUVelocity(msg[2]);
                        }
                        //console.log("NoteOn: key=" + data[1] + ", velocity=" + data[2]);
                        break;
                    case CMD.CONTROL_CHANGE:
                        updateGUI_ControlsTable(data[1], data[2]);
                        //console.log("control change: " + getMsgString(data));
                        break;
                    case CMD.PRESET:
                        //console.log("preset: " + getMsgString(data));
                        break;
                    case CMD.PITCHWHEEL:
                        // This host uses pitchWheel values in range 0..127, so data[1] (the fine byte) is ignored here.
                        // But note that the residentSynth _does_ use both data[1] and data[2] when responding
                        // to PITCHWHEEL messages (including those that come from the E-MU keyboard), so PITCHWHEEL
                        // messages sent from this host's GUI use a data[1] value that is calculated on the fly.
                        updateGUI_CommandsTable(command, data[2]);
                        //console.log("pitchWheel: value=" + data[2]);
                        break;
                    case HOST_CMD_CHANNEL_PRESSURE: // Host ChannelPressure (ResidentSynth does not implement ChannelPressure)
                        {
                            if(globalChannelPressureType === "unused")
                            {
                                return
                            }
                            else
                            {
                                let CTL = ResSynth.constants.CONTROL,
                                    channel = currentChannel,
                                    hostChannelSettings = getElem("channelSelect").options[currentChannel].hostSettings,
                                    channelPressureComponent = Math.round(data[1] * globalChannelPressureFactor);

                                // console.log(`channelPressure = ${data[1]}, globalChannelPressureFactor = ${globalChannelPressureFactor}, channelPressureComponent = ${channelPressureComponent}`);

                                // The residentSynth does not process CHANNEL_PRESSURE messages.
                                // They are ignored or converted here.
                                switch(globalChannelPressureType)
                                {
                                    case "pitchWheelUp":
                                        {
                                            msg[0] = CMD.PITCHWHEEL + channel;
                                            msg[1] = midiValue(hostChannelSettings.pitchWheel + channelPressureComponent);
                                            msg[2] = msg[1];
                                            break;
                                        }
                                    case "pitchWheelDown":
                                        {
                                            msg[0] = CMD.PITCHWHEEL + channel;
                                            msg[1] = midiValue(hostChannelSettings.pitchWheel - channelPressureComponent);
                                            msg[2] = msg[1];
                                            break;
                                        }
                                    case "modWheelUp":
                                        {
                                            msg[0] = CMD.CONTROL_CHANGE + channel;
                                            msg[1] = CTL.MODWHEEL;
                                            msg[2] = midiValue(hostChannelSettings.modWheel + channelPressureComponent);
                                            break;
                                        }
                                    case "modWheelDown":
                                        {
                                            msg[0] = CMD.CONTROL_CHANGE + channel;
                                            msg[1] = CTL.MODWHEEL;
                                            msg[2] = midiValue(hostChannelSettings.modWheel - channelPressureComponent);
                                            break;
                                        }
                                    case "volumeUp":
                                        {
                                            msg[0] = CMD.CONTROL_CHANGE + channel;
                                            msg[1] = CTL.VOLUME;
                                            msg[2] = midiValue(hostChannelSettings.volume + channelPressureComponent);
                                            break;
                                        }
                                    case "volumeDown":
                                        {
                                            msg[0] = CMD.CONTROL_CHANGE + channel;
                                            msg[1] = CTL.VOLUME;
                                            msg[2] = midiValue(hostChannelSettings.volume - channelPressureComponent);
                                            break;
                                        }
                                    case "expressionUp":
                                        {
                                            msg[0] = CMD.CONTROL_CHANGE + channel;
                                            msg[1] = CTL.EXPRESSION;
                                            msg[2] = midiValue(hostChannelSettings.expression + channelPressureComponent);
                                            break;
                                        }
                                    case "expressionDown":
                                        {
                                            msg[0] = CMD.CONTROL_CHANGE + channel;
                                            msg[1] = CTL.EXPRESSION;
                                            msg[2] = midiValue(hostChannelSettings.expression - channelPressureComponent);
                                            break;
                                        }
                                    case "panLeft":
                                        {
                                            msg[0] = CMD.CONTROL_CHANGE + channel;
                                            msg[1] = CTL.PAN;
                                            msg[2] = midiValue(hostChannelSettings.pan - channelPressureComponent);
                                            break;
                                        }
                                    case "panRight":
                                        {
                                            msg[0] = CMD.CONTROL_CHANGE + channel;
                                            msg[1] = CTL.PAN;
                                            msg[2] = midiValue(hostChannelSettings.pan + channelPressureComponent);
                                            break;
                                        }
                                    case "reverberationUp":
                                        {
                                            msg[0] = CMD.CONTROL_CHANGE + channel;
                                            msg[1] = CTL.REVERBERATION;
                                            msg[2] = midiValue(hostChannelSettings.reverberation + channelPressureComponent);
                                            break;
                                        }
                                    case "reverberationDown":
                                        {
                                            msg[0] = CMD.CONTROL_CHANGE + channel;
                                            msg[1] = CTL.REVERBERATION;
                                            msg[2] = midiValue(hostChannelSettings.reverberation - channelPressureComponent);
                                            break;
                                        }
                                }
                            }
                        }
                }

                if(recordedMessages !== undefined
                    && recordingChannelIndices !== undefined && recordingChannelIndices.includes(currentChannel)
                    && command === CMD.NOTE_ON)
                {
                    cancelPlayback = true;
                    recordingNoteOnError = true;
                }
                else
                {
                    sendMessage(msg, currentChannel);
                }
            }

            // if(inputDevice !== null) // 21.06.2024 replace by "if(inputDevice)". (undefined and null are falsy)
            if(inputDevice) // 29.06.2024: both undefined and null are falsy
            {
                inputDevice.removeEventListener("midimessage", handleInputMessage, false);
                inputDevice.close()
                    .then((device) => {console.log("Closed " + device.name);})
                    .catch((device) => {console.error("Error closing " + device.name);});
            }

            inputDevice = inputDeviceSelect.options[inputDeviceSelect.selectedIndex].inputDevice;
            if(inputDevice) // 29.06.2024: both undefined and null are falsy
            {
                inputDevice.addEventListener("midimessage", handleInputMessage, false);
                inputDevice.open()
                    .then((device) => {console.log("Opened " + device.name);})
                    .catch((device) => {console.error("Error opening " + device.name);});
            }
            else
            {
                // 29.06.2024 deleted the following line
                // throwError("Error: the input device is not set in the device select control.");
                inputDeviceSelect.disabled = true;
            }
        },

        // exported
        onInputDeviceSelectChanged = function()
        {
            let inputDeviceSelect = getElem("inputDeviceSelect");

            setInputDeviceEventListener(inputDeviceSelect);
        },

        // exported
        // See: https://developer.chrome.com/blog/audiocontext-setsinkid/
        onAudioDeviceSelectChanged = function()
        {
            let audioDeviceSelect = getElem("audioDeviceSelect"),
                option = audioDeviceSelect.options[audioDeviceSelect.selectedIndex],
                deviceId = (option.deviceId === "default") ? "" : option.deviceId;

            synth.setAudioOutputDevice(deviceId);
        },

        // Called by 'gitHub' and 'website' buttons
        openInNewTab = function(url)
        {
            var win = window.open(url, '_blank');
            win.focus();
        },

        // exported
        webAudioFontWebsiteButtonClick = function()
        {
            let bankSelect = getElem("bankSelect"),
                selectedOption = bankSelect[bankSelect.selectedIndex];

            openInNewTab(selectedOption.url);
        },

        // exported
        onChannelSelectChanged = function()
        {
            function setAndSendWebAudioFontDivControls(hostChannelSettings)
            {
                let bankSelect = getElem("bankSelect");

                bankSelect.selectedIndex = hostChannelSettings.bankIndex; // index in bankSelect

                // set the soundFont in the synth, and the presetSelect then call onPresetSelectChanged() (which calls onMixtureSelectChanged())
                onBankSelectChanged();
            }

            function setAndSendTuningDivControls(hostChannelSettings)
            {
                let tuningGroupSelect = getElem("tuningGroupSelect");

                tuningGroupSelect.selectedIndex = hostChannelSettings.tuningGroupIndex;

                // set the tuningSelect then call onTuningtSelectChanged()
                // (which calls onSemitonesOffsetNumberInputChanged() and onCentsOffsetNumberInputChanged())
                onTuningGroupSelectChanged();
            }

            function setAndSendLongControls(hostChannelSettings)
            {
                let pitchWheelLC = getElem("pitchWheelLongControl"),
                    modWheelLC = getElem("modWheelLongControl"),
                    volumeLC = getElem("volumeLongControl"),
                    expressionLC = getElem("expressionLongControl"),
                    panLC = getElem("panLongControl"),
                    reverberationLC = getElem("reverberationLongControl"),
                    pitchWheelSensitivityLC = getElem("pitchWheelSensitivityLongControl"),
                    velocityPitchSensitivityLC = getElem("velocityPitchSensitivityLongControl");

                pitchWheelLC.setValue(hostChannelSettings.pitchWheel);
                modWheelLC.setValue(hostChannelSettings.modWheel);
                volumeLC.setValue(hostChannelSettings.volume);
                expressionLC.setValue(hostChannelSettings.expression);
                panLC.setValue(hostChannelSettings.pan);
                reverberationLC.setValue(hostChannelSettings.reverberation);
                pitchWheelSensitivityLC.setValue(hostChannelSettings.pitchWheelSensitivity);
                velocityPitchSensitivityLC.setValue(hostChannelSettings.velocityPitchSensitivity);
            }

            function setAndSendOrnamentsDivControls(hostChannelSettings)
            {
                let ornamentsSelect = getElem("ornamentsSelect");

                ornamentsSelect.selectedIndex = hostChannelSettings.keyboardOrnamentsArrayIndex;
                onOrnamentsSelectChanged();
            }

            let channelSelect = getElem("channelSelect"),
                startRecordingButtonInput = getElem("startRecordingButtonInput"),
                stopRecordingButtonInput = getElem("stopRecordingButtonInput"),
                channel = channelSelect.selectedIndex,
                hostChannelSettings = channelSelect.options[channel].hostSettings;

            currentChannel = channel; // the global currentChannel is used when constructing all midi messages

            setAndSendWebAudioFontDivControls(hostChannelSettings);
            setAndSendTuningDivControls(hostChannelSettings);

            setAndSendLongControls(hostChannelSettings);

            setAndSendOrnamentsDivControls(hostChannelSettings);

            startRecordingButtonInput.value = "start recording ch" + channel.toString();
            stopRecordingButtonInput.value = "stop recording ch" + channel.toString();
        },

        // exported
        onBankSelectChanged = function()
        {
            function getBankIndexMsg(channel, bankIndex)
            {
                return new Uint8Array([ResSynth.constants.COMMAND.CONTROL_CHANGE + channel, ResSynth.constants.CONTROL.BANK, bankIndex]);
            }

            function getPresetIndexMsg(channel, presetIndex)
            {
                return new Uint8Array([ResSynth.constants.COMMAND.PRESET + channel, presetIndex]);
            }

            let bankSelect = getElem("bankSelect"),
                channelSelect = getElem("channelSelect"),
                channel = channelSelect.selectedIndex,
                hostChannelSettings = channelSelect.options[channel].hostSettings,
                presetSelect = getElem("presetSelect"),
                selectedBankOption = bankSelect[bankSelect.selectedIndex],
                presetOptionsArray = selectedBankOption.presetOptionsArray,
                bankIndexMsg = getBankIndexMsg(channel, bankSelect.selectedIndex),
                hostChannelPresetIndex = (hostChannelSettings.presetIndex < presetOptionsArray.length) ? hostChannelSettings.presetIndex : 0,
                presetIndexMsg = getPresetIndexMsg(channel, hostChannelPresetIndex);

            sendMessage(bankIndexMsg, channel);
            sendMessage(presetIndexMsg, channel);

            setOptions(presetSelect, presetOptionsArray);

            presetSelect.selectedIndex = hostChannelPresetIndex;
            onPresetSelectChanged();

            hostChannelSettings.bankIndex = bankSelect.selectedIndex;
        },

        // exported
        onPresetSelectChanged = function()
        {
            function getPresetMsg(channel, presetIndex)
            {
                return new Uint8Array([ResSynth.constants.COMMAND.PRESET + channel, presetIndex]);
            }

            let channelSelect = getElem("channelSelect"),
                presetSelect = getElem("presetSelect"),
                mixtureSelect = getElem("mixtureSelect"),
                channel = channelSelect.selectedIndex,
                hostChannelSettings = channelSelect.options[channel].hostSettings,
                presetIndex = presetSelect.selectedIndex,
                presetMsg = getPresetMsg(channel, presetIndex);

            sendMessage(presetMsg, channel);

            mixtureSelect.selectedIndex = hostChannelSettings.mixtureIndex;
            onMixtureSelectChanged();

            hostChannelSettings.presetIndex = presetSelect.selectedIndex;
        },

        // exported
        onMixtureSelectChanged = function()
        {
            function getMixtureMsg(channel, mixtureIndex)
            {
                return new Uint8Array([CMD.CONTROL_CHANGE + channel, CTL.MIXTURE_INDEX, mixtureIndex]);
            }

            let CMD = ResSynth.constants.COMMAND,
                CTL = ResSynth.constants.CONTROL,
                channelSelect = getElem("channelSelect"),
                mixtureSelect = getElem("mixtureSelect"),
                channel = channelSelect.selectedIndex,
                hostChannelSettings = channelSelect.options[channel].hostSettings,
                mixtureIndex = mixtureSelect.selectedIndex,
                mixtureMessage = getMixtureMsg(channel, mixtureIndex);

            sendMessage(mixtureMessage, channel);

            hostChannelSettings.mixtureIndex = mixtureIndex;
        },

        // exported (c.f. onBankSelectChanged() )
        onTuningGroupSelectChanged = function()
        {
            let channelSelect = getElem("channelSelect"),
                channel = channelSelect.selectedIndex,
                hostChannelSettings = channelSelect.options[channel].hostSettings,
                tuningGroupSelect = getElem("tuningGroupSelect"),
                tuningSelect = getElem("tuningSelect"),
                selectedTuningGroupOption = tuningGroupSelect[tuningGroupSelect.selectedIndex],
                tuningOptionsArray = selectedTuningGroupOption.tuningOptionsArray,
                hostChannelTuningIndex = (hostChannelSettings.tuningIndex < tuningOptionsArray.length) ? hostChannelSettings.tuningIndex : 0;

            setOptions(tuningSelect, tuningOptionsArray);

            tuningSelect.selectedIndex = hostChannelTuningIndex;
            onTuningSelectChanged();

            hostChannelSettings.tuningGroupIndex = tuningGroupSelect.selectedIndex;
        },

        // exported
        onTuningSelectChanged = function()
        {
            let channelSelect = getElem("channelSelect"),
                tuningGroupIndex = getElem("tuningGroupSelect").selectedIndex,
                semitonesOffsetNumberInput = getElem("semitonesOffsetNumberInput"),
                centsOffsetNumberInput = getElem("centsOffsetNumberInput"),
                tuningSelect = getElem("tuningSelect"),
                tuningIndex = tuningSelect.selectedIndex,
                channel = channelSelect.selectedIndex,
                hostChannelSettings = channelSelect.options[channel].hostSettings,
                CONST = ResSynth.constants,
                setTuningGroupIndexMsg = new Uint8Array([((currentChannel + CONST.COMMAND.CONTROL_CHANGE) & 0xFF), CONST.CONTROL.TUNING_GROUP_INDEX, tuningGroupIndex]),
                setTuningIndexMsg = new Uint8Array([((currentChannel + CONST.COMMAND.CONTROL_CHANGE) & 0xFF), CONST.CONTROL.TUNING_INDEX, tuningIndex]);

            sendMessage(setTuningGroupIndexMsg, channel);
            sendMessage(setTuningIndexMsg, channel);

            semitonesOffsetNumberInput.value = hostChannelSettings.semitonesOffset;
            onSemitonesOffsetNumberInputChanged();

            centsOffsetNumberInput.value = hostChannelSettings.centsOffset;
            onCentsOffsetNumberInputChanged();

            hostChannelSettings.tuningIndex = tuningIndex;
        },

        // exported
        onSemitonesOffsetNumberInputChanged = function()
        {
            let CONST = ResSynth.constants,
                channelSelect = getElem("channelSelect"),
                channel = channelSelect.selectedIndex,
                hostChannelSettings = channelSelect.options[channel].hostSettings,
                semitonesOffsetNumberInput = getElem("semitonesOffsetNumberInput"),
                semitonesOffset = parseInt(semitonesOffsetNumberInput.value),
                midiValue = semitonesOffsetNumberInput.midiValue(semitonesOffset),
                semitonesOffsetMsg = new Uint8Array([((currentChannel + CONST.COMMAND.CONTROL_CHANGE) & 0xFF), CONST.CONTROL.SEMITONES_OFFSET, midiValue]);

            sendMessage(semitonesOffsetMsg, channel);

            hostChannelSettings.semitonesOffset = semitonesOffset;
        },
        // exported
        onCentsOffsetNumberInputChanged = function()
        {
            let CONST = ResSynth.constants,
                channelSelect = getElem("channelSelect"),
                channel = channelSelect.selectedIndex,
                hostChannelSettings = channelSelect.options[channel].hostSettings,
                centsOffsetNumberInput = getElem("centsOffsetNumberInput"),
                centsOffset = parseInt(centsOffsetNumberInput.value);

            let midiValue = centsOffsetNumberInput.midiValue(centsOffset),
                centsOffsetMsg = new Uint8Array([((channel + CONST.COMMAND.CONTROL_CHANGE) & 0xFF), CONST.CONTROL.CENTS_OFFSET, midiValue]);

            sendMessage(centsOffsetMsg, channel);

            hostChannelSettings.centsOffset = centsOffset;
        },

        onSettingsSelectChanged = function() // always updates both host and synth
        {
            function setGlobalSettingsInHost(settingsSelect, settingsChangePerSection)
            {
                let selectedIndex = settingsSelect.selectedIndex,
                    changedSettings = settingsChangePerSection[selectedIndex],
                    keyboardSplitIndex = changedSettings.keyboardSplitIndex;

                if(selectedIndex === 0)
                {
                    console.assert(keyboardSplitIndex !== undefined);
                }

                if(keyboardSplitIndex !== undefined)
                {
                    let keyboardSplitSelect = getElem("keyboardSplitSelect");

                    keyboardSplitSelect.selectedIndex = keyboardSplitIndex;
                    onKeyboardSplitSelectChanged();
                }
            }

            function setChannelSettingsInHostAndSynth(settingsSelect, settingsChangePerSection)
            {
                function updateChannels(changedSettings)
                {
                    function updateAttribute(attributeName, value)
                    {
                        switch(attributeName)
                        {
                            case "bankIndex":
                                {
                                    getElem("bankSelect").selectedIndex = value;
                                    onBankSelectChanged();
                                    break;
                                }
                            case "presetIndex":
                                {
                                    getElem("presetSelect").selectedIndex = value;
                                    onPresetSelectChanged();
                                    break;
                                }
                            case "mixtureIndex":
                                {
                                    getElem("mixtureSelect").selectedIndex = value;
                                    onMixtureSelectChanged();
                                    break;
                                }
                            case "tuningGroupIndex":
                                {
                                    getElem("tuningGroupSelect").selectedIndex = value;
                                    onTuningGroupSelectChanged();
                                    break;
                                }
                            case "tuningIndex":
                                {
                                    getElem("tuningSelect").selectedIndex = value;
                                    onTuningSelectChanged();
                                    break;
                                }
                            case "semitonesOffset":
                                {
                                    getElem("semitonesOffsetNumberInput").value = value;
                                    onSemitonesOffsetNumberInputChanged();
                                    break;
                                }
                            case "centsOffset":
                                {
                                    getElem("centsOffsetNumberInput").value = value;
                                    onCentsOffsetNumberInputChanged();
                                    break;
                                }
                            case "pitchWheel":
                                {
                                    getElem("pitchWheelLongControl").setValue(value); // also sets synth
                                    break;
                                }
                            case "modWheel":
                                {
                                    getElem("modWheelLongControl").setValue(value); // also sets synth
                                    break;
                                }
                            case "volume":
                                {
                                    getElem("volumeLongControl").setValue(value); // also sets synth
                                    break;
                                }
                            case "expression":
                                {
                                    getElem("expressionLongControl").setValue(value); // also sets synth
                                    break;
                                }
                            case "pan":
                                {
                                    getElem("panLongControl").setValue(value); // also sets synth
                                    break;
                                }
                            case "reverberation":
                                {
                                    getElem("reverberationLongControl").setValue(value); // also sets synth
                                    break;
                                }
                            case "pitchWheelSensitivity":
                                {
                                    getElem("pitchWheelSensitivityLongControl").setValue(value); // also sets synth
                                    break;
                                }
                            case "velocityPitchSensitivity":
                                {
                                    getElem("velocityPitchSensitivityLongControl").setValue(value); // also sets synth
                                    break;
                                }
                            case "keyboardOrnamentsArrayIndex":
                                {
                                    getElem("ornamentsSelect").selectedIndex = value;
                                    onOrnamentsSelectChanged();
                                    break;
                                }
                            default: throw "error";
                        }
                    }

                    let channelSelect = getElem("channelSelect"),
                        savedChannel = channelSelect.selectedIndex,
                        channelSettingsArray = changedSettings.channelSettings;

                    for(let channel = 0; channel < channelSettingsArray.length; channel++)
                    {
                        channelSelect.selectedIndex = channel; // used by the event handling functions in updateAttribute()
                        currentChannel = channel; // global currentChannel is used to construct messages sent to the synth

                        let channelSettings = channelSettingsArray[channel],
                            attributeNames = Object.keys(channelSettings);

                        // update host and synth channel settings with each defined channel attribute.
                        for(let keyIndex = 0; keyIndex < attributeNames.length; keyIndex++)
                        {
                            let attributeName = attributeNames[keyIndex],
                                newValue = channelSettings[attributeName];

                            updateAttribute(attributeName, newValue);
                        }
                    }

                    channelSelect.selectedIndex = savedChannel;
                    onChannelSelectChanged(); // resets currentChannel and the GUI
                }

                let selectedIndex = settingsSelect.selectedIndex;

                // must start at 0 because user may have changed GUI settings
                for(let i = 0; i <= selectedIndex; i++)
                {
                    let changedSettings = settingsChangePerSection[i];
                    updateChannels(changedSettings);
                }
            }

            let settingsSelect = getElem("settingsSelect");

            // The settingsSelect.settingsChangePerSection contains an array of sectionSettings, each of which
            // contains only those settings that change from section to section (i.e. over time).
            // The sectionSettings object at index 0 contains values that initialize _all_ the attributes in all
            // the channels that are defined in synthSettingsDefs.js.

            setGlobalSettingsInHost(settingsSelect, settingsSelect.settingsChangePerSection);
            setChannelSettingsInHostAndSynth(settingsSelect, settingsSelect.settingsChangePerSection);

            settingsSelect.previousIndex = settingsSelect.selectedIndex;
        },

        // exported
        // Exports the current settings in a format similar to that of synthSettingsDefs.js
        onExportSettingsButtonClicked = function()
        {
            function getChangedChannelSettingsArray(hostChannelOptions)
            {
                function removeTrailingDefaultSettings(defaultSettings, changedChannelSettingsArray)
                {
                    for(let ch = 15; ch >= 0; ch--)
                    {
                        if(defaultSettings.isSimilar(changedChannelSettingsArray[ch])) // isSimilar ignores the _comment attributes
                        {
                            changedChannelSettingsArray.length -= 1;
                        }
                        else
                        {
                            break;
                        }
                    }
                }

                function addDefaultComments(defaultSettings, changedChannelSettingsArray)
                {
                    for(let channel = 0; channel < changedChannelSettingsArray.length; channel++)
                    {
                        let changedChannelSettings = changedChannelSettingsArray[channel];

                        if(defaultSettings.isSimilar(changedChannelSettings)) // isSimilar ignores the ._comment attribute
                        {
                            changedChannelSettings._comment = changedChannelSettings._comment + ` (default settings)`;
                        }
                    }
                }

                let changedChannelSettingsArray = [],
                    defaultSettings = new ResSynth.channelSettings.ChannelSettings();

                for(let channel = 0; channel < 16; channel++)
                {
                    let hostSettings = hostChannelOptions[channel].hostSettings,
                        exportChannelSettings = {};

                    exportChannelSettings._comment = `channel ${channel}`;
                    exportChannelSettings.bankIndex = hostSettings.bankIndex;
                    exportChannelSettings.presetIndex = hostSettings.presetIndex;
                    exportChannelSettings.mixtureIndex = hostSettings.mixtureIndex;
                    exportChannelSettings.tuningGroupIndex = hostSettings.tuningGroupIndex;
                    exportChannelSettings.tuningIndex = hostSettings.tuningIndex;
                    exportChannelSettings.semitonesOffset = hostSettings.semitonesOffset;
                    exportChannelSettings.centsOffset = hostSettings.centsOffset;
                    exportChannelSettings.pitchWheel = hostSettings.pitchWheel;
                    exportChannelSettings.modWheel = hostSettings.modWheel;
                    exportChannelSettings.volume = hostSettings.volume;
                    exportChannelSettings.expression = hostSettings.expression;
                    exportChannelSettings.pan = hostSettings.pan;
                    exportChannelSettings.reverberation = hostSettings.reverberation;
                    exportChannelSettings.pitchWheelSensitivity = hostSettings.pitchWheelSensitivity;
                    exportChannelSettings.velocityPitchSensitivity = hostSettings.velocityPitchSensitivity;
                    exportChannelSettings.keyboardOrnamentsArrayIndex = hostSettings.keyboardOrnamentsArrayIndex;

                    changedChannelSettingsArray.push(exportChannelSettings);
                }

                removeTrailingDefaultSettings(defaultSettings, changedChannelSettingsArray);

                addDefaultComments(defaultSettings, changedChannelSettingsArray);

                return changedChannelSettingsArray;
            }

            let hostChannelOptions = getElem("channelSelect").options,
                keyboardSplitIndex = getElem("keyboardSplitSelect").selectedIndex,
                changedChannelSettingsArray = getChangedChannelSettingsArray(hostChannelOptions),
                exportSettings = {};

            exportSettings.name = "exported synth settings";
            exportSettings.keyboardSplitIndex = keyboardSplitIndex;
            if(changedChannelSettingsArray.length < 16)
            {
                exportSettings._comment = `Channels ${changedChannelSettingsArray.length}..15 contain the default settings`;
            }
            exportSettings.channelSettingsArray = changedChannelSettingsArray;

            const a = document.createElement("a");
            a.href = URL.createObjectURL(new Blob([JSON.stringify(exportSettings, null, "\t")], {type: "text/plain"}));
            a.setAttribute("download", exportSettings.name + ".json");
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        },

        // not exported, this function is bound internally
        onQuertyKeyDown = function(event)
        {
            // increments or rotates the index if toIndex is less than 0 or out of range.
            // otherwise sets the index to toIndex.
            function setSettingsSelectIndex(toIndex)
            {
                let settingsSelect = getElem("settingsSelect"),
                    nOptions = settingsSelect.options.length;

                settingsSelect.previousIndex = settingsSelect.selectedIndex;

                toIndex = (toIndex >= 0 && toIndex < nOptions) ? toIndex : settingsSelect.previousIndex + 1;
                toIndex = (toIndex === nOptions) ? 0 : toIndex; 

                settingsSelect.selectedIndex = toIndex;

                onSettingsSelectChanged();
            }

            if(event.repeat)
            {
                return; // stops the reaction to a repeating key
            }

            let keyCode = event.keyCode;
            if(keyCode === 32)
            { 
                // space
                console.log(event.key);
                // advance/rotate settings selector
                setSettingsSelectIndex(-1);
            }
            else if(keyCode >= 48 && keyCode <= 57)
            {
                // '0'..'9'
                console.log(event.key);
                // set the settingsSelect.selectedIndex
                setSettingsSelectIndex(keyCode - 48);
            }
            else if(keyCode >= 65 && keyCode <= 90)
            {
                // 'a'..'z'
                setSettingsSelectIndex(keyCode - 55); // indices 10..35
            }
        },

        // exported
        onplayRecordingButtonInputClicked = async function()
        {
            function getHostChannelState()
            {
                let channelSelect = getElem("channelSelect"),
                    channelIndex = channelSelect.selectedIndex,
                    hostChannelState = {};

                hostChannelState.channelIndex = channelIndex;

                return hostChannelState;
            }

            function setInitialRecordingButtonState(b)
            {
                if(b.startRecordingButtonInput.style.display === "block")
                {
                    setPerformanceGUIState2();
                }
                else if(b.stopRecordingButtonInput.style.display === "block")
                {
                    setPerformanceGUIState4();
                }
                else if(b.saveRecordingButtonInput.style.display === "block")
                {
                    setPerformanceGUIState6();
                }
            }

            function setFinalRecordingButtonState(b)
            {
                if(b.startRecordingButtonInput.style.display === "block")
                {
                    setPerformanceGUIState1();
                }
                else if(b.stopRecordingButtonInput.style.display === "block")
                {
                    setPerformanceGUIState3();
                }
                else
                {
                    setPerformanceGUIState5();
                }
            }

            function restoreHostAndSynthChannelState(hostChannelState)
            {
                let channelSelect = getElem("channelSelect");

                channelSelect.selectedIndex = hostChannelState.channelIndex;
                onChannelSelectChanged();
            }

            function getRecordingChannelIndices(currentRecording, presetRecording)
            {
                let recordingChannelIndices = [],
                    currentRecordingChannel = -1;

                if(currentRecording !== undefined)
                {
                    currentRecordingChannel = currentRecording.channels[0].channel;
                    recordingChannelIndices.push(currentRecordingChannel);
                }

                if(presetRecording !== undefined)
                {
                    let channelInfos = presetRecording.channels;
                    for(let i = 0; i < channelInfos.length; i++)
                    {
                        let channel = channelInfos[i].channel;
                        if(channel != currentRecordingChannel)
                        {
                            recordingChannelIndices.push(channel);
                        }
                    }
                }

                recordingChannelIndices.sort((a, b) => a - b);

                return recordingChannelIndices;
            }

            function sendMessages(recording)
            {
                let channelInfos = recording.channels;
                // Recordings contain appropriate setOrnament messages, which this function simply relays to the synth.
                // There is therefore no need to call checkSendSetOrnament(..) before noteOns in this function.
                async function sendChannelMessages(channelInfos, infoIndex)
                {
                    // This function only sends messages to the synth, not to the recording.
                    function setSynthChannelToSettings(channel, channelSettings)
                    {
                        let CMD = ResSynth.constants.COMMAND,
                            CTL = ResSynth.constants.CONTROL,
                            cmdControl = CMD.CONTROL_CHANGE + channel,
                            semitonesOffsetNumberInput = getElem("semitonesOffsetNumberInput"),
                            centsOffsetNumberInput = getElem("centsOffsetNumberInput");

                        // channelSettings.bankIndex
                        let bankIndexMsg = new Uint8Array([cmdControl, CTL.BANK, channelSettings.bankIndex]);
                        synth.send(bankIndexMsg);
                        // channelSettings.presetIndex
                        let presetMsg = new Uint8Array([CMD.PRESET + channel, channelSettings.presetIndex]);
                        synth.send(presetMsg);
                        // channelSettings.mixtureIndex
                        let mixtureMessage = new Uint8Array([cmdControl, CTL.MIXTURE_INDEX, channelSettings.mixtureIndex]);
                        synth.send(mixtureMessage);
                        // channelSettings.tuningGroupIndex
                        let tuningGroupIndexMsg = new Uint8Array([cmdControl, CTL.TUNING_GROUP_INDEX, channelSettings.tuningGroupIndex]);
                        synth.send(tuningGroupIndexMsg);
                        // channelSettings.tuningIndex
                        let tuningIndexMsg = new Uint8Array([cmdControl, CTL.TUNING_INDEX, channelSettings.tuningIndex]);
                        synth.send(tuningIndexMsg);
                        // channelSettings.semitonesOffset
                        let sMidiValue = semitonesOffsetNumberInput.midiValue(channelSettings.semitonesOffset);
                        let semitonesOffsetMsg = new Uint8Array([cmdControl, CTL.SEMITONES_OFFSET, sMidiValue]);
                        synth.send(semitonesOffsetMsg);
                        // channelSettings.centsOffset
                        let cMidiValue = centsOffsetNumberInput.midiValue(channelSettings.centsOffset);
                        let centsOffsetMsg = new Uint8Array([cmdControl, CTL.CENTS_OFFSET, cMidiValue]);
                        synth.send(centsOffsetMsg);
                        // channelSettings.pitchWheel
                        let pitchWheelMsg = new Uint8Array([CMD.PITCHWHEEL + channel, channelSettings.pitchWheel, channelSettings.pitchWheel]);
                        synth.send(pitchWheelMsg);
                        // channelSettings.modWheel
                        let modWheelMsg = new Uint8Array([cmdControl, CTL.MODWHEEL, channelSettings.modWheel]);
                        synth.send(modWheelMsg);
                        // channelSettings.volume
                        let volMsg = new Uint8Array([cmdControl, CTL.VOLUME, channelSettings.volume]);
                        synth.send(volMsg);
                        // channelSettings.expression
                        let exprMsg = new Uint8Array([cmdControl, CTL.EXPRESSION, channelSettings.expression]);
                        synth.send(exprMsg);
                        // channelSettings.pan
                        let panMsg = new Uint8Array([cmdControl, CTL.PAN, channelSettings.pan]);
                        synth.send(panMsg);
                        // channelSettings.reverberation 
                        let reverbMsg = new Uint8Array([cmdControl, CTL.REVERBERATION, channelSettings.reverberation]);
                        synth.send(reverbMsg);
                        // channelSettings.pitchWheelSensitivity
                        let pwsMsg = new Uint8Array([cmdControl, CTL.PITCH_WHEEL_SENSITIVITY, channelSettings.pitchWheelSensitivity]);
                        synth.send(pwsMsg);
                        // channelSettings.velocityPitchSensitivity
                        let vpsMsg = new Uint8Array([cmdControl, CTL.VELOCITY_PITCH_SENSITIVITY, channelSettings.velocityPitchSensitivity]);
                        synth.send(vpsMsg);
                        // channelSettings.keyboardOrnamentsArrayIndex
                        let koaMsg = new Uint8Array([cmdControl, CTL.SET_KEYBOARD_ORNAMENT_DEFS, channelSettings.keyboardOrnamentsArrayIndex]);
                        synth.send(koaMsg);
                    }

                    function wait(delay, cancel)
                    {
                        if(!cancel)
                        {
                            return new Promise(resolve => setTimeout(resolve, delay));
                        }
                    }

                    let prevMsPos = 0,
                        channelInfo = channelInfos[infoIndex],
                        channel = channelInfo.channel,
                        channelSettings = channelInfo.channelSettings,
                        channelMessages = channelInfo.messages,
                        channelIndex = channelInfo.channel;

                    setSynthChannelToSettings(channel, channelSettings);

                    for(let mIndex = 0; mIndex < channelMessages.length; mIndex++)
                    {
                        let playbackMessage = channelMessages[mIndex],
                            pbMsg = playbackMessage.msg,
                            thisMsPos = playbackMessage.msPositionReRecording,
                            delay = thisMsPos - prevMsPos;

                        if(cancelPlayback)
                        {
                            for(let i = 0; i < channelInfos.length; i++)
                            {
                                let channel = channelInfos[i].channel,
                                    CMD = ResSynth.constants.COMMAND,
                                    CTL = ResSynth.constants.CONTROL,
                                    msg = new Uint8Array([((channel + CMD.CONTROL_CHANGE) & 0xFF), CTL.ALL_SOUND_OFF, 0]);

                                synth.send(msg); // Don't use sendMessage(...) here. These messages don't belong in a recording!
                            }
                            break;
                        }

                        await wait(delay, cancelPlayback);
                        sendMessage(pbMsg, channelIndex);
                        playbackMessage.now = performance.now();

                        prevMsPos = thisMsPos;
                    }
                }

                let promises = [];
                for(let infoIndex = 0; infoIndex < channelInfos.length; infoIndex++) 
                {
                    promises.push(sendChannelMessages(channelInfos, infoIndex)); // async (send all channels in parallel)
                }
                return promises;
            }

            let presetRecording = presetRecordings[getElem("recordingSelect").selectedIndex],
                hostChannelState = getHostChannelState(),
                b = getRecordingButtons(),
                // currentRecording only exists after clicking onstopRecordingButtonInput.
                recordingToPlay = (currentRecording === undefined) ? presetRecording : currentRecording;

            setInitialRecordingButtonState(b);

            recordingChannelIndices = getRecordingChannelIndices(currentRecording, presetRecording); // recordingChannelIndices is global            

            let promises = sendMessages(recordingToPlay);

            // Wait for all channels to complete, before calling tidyUp().
            await Promise.allSettled(promises);

            recordingChannelIndices = undefined;

            if(cancelPlayback)
            {
                if(recordingNoteOnError)
                {
                    alert("Recording Aborted:\n\n" +
                        "Either:\n" +
                        "    The 'cancel playback' button was clicked.\n" +
                        "Or:\n" +
                        "    An attempt was made to record noteOns in an existing channel.\n" +
                        "    Only commands and controls can be overdubbed in an existing channel.\n");

                    onstopRecordingButtonInputClicked();
                }
                else
                {
                    alert("Playback Canceled:\n\n" +
                        "The 'cancel playback' button was clicked.");
                }
                cancelPlayback = false;
            }

            setFinalRecordingButtonState(b);

            restoreHostAndSynthChannelState(hostChannelState);
        },

        // exported
        oncancelPlaybackButtonInputClicked = function()
        {
            cancelPlayback = true; // global

            if(getElem("startRecordingButtonInput").style.display === "block")
            {
                setPerformanceGUIState1();
            }
            else if(getElem("stopRecordingButtonInput").style.display === "block")
            {
                setPerformanceGUIState3();
            }
            else
            {
                setPerformanceGUIState5();
            }
        },

        setDivDisabled = function(div, disabled)
        {
            let nodes = div.getElementsByTagName('*');
            for(let i = 0; i < nodes.length; i++)
            {
                nodes[i].disabled = disabled;
            }
        },

        restoreStateAfterRecording = function()
        {

            function restoreOtherHostControlDivs()
            {
                let presetSettingsDiv = getElem("presetSettingsDiv"),
                    channelPressureDiv = getElem("channelPressureDiv"),
                    keyboardSplitDiv = getElem("keyboardSplitDiv"),
                    settingsSelect = getElem("settingsSelect");

                setDivDisabled(presetSettingsDiv, false);
                setDivDisabled(channelPressureDiv, false);
                setDivDisabled(keyboardSplitDiv, false);
            }

            function restoreRecordingsDiv()
            {
                getElem("recordingTitle").style.color = "black";
                getElem("recordingSelect").disabled = false;

                setPerformanceGUIState1();
            }

            function restoreHostAndSynthSettings()
            {
                let channelSelect = getElem("channelSelect");

                channelSelect.disabled = false;

                if(recordingChannelIndices !== undefined)
                {
                    for(let i = 0; i < recordingChannelIndices.length; i++)
                    {
                        channelSelect.selectedIndex = recordingChannelIndices[i].channel;
                        onChannelSelectChanged(); // reloads the host settings and sets the synth (without recording the sent messages)
                    }
                }
            }

            function restoreHostGlobalRecordingVariables()
            {
                // set by startRecording(), undefined by stopRecording() or discardRecording()
                settingsBeforeRecording = undefined; // array of 16 currentSettings objects
                recordedMessages = undefined; // array of 16 messages arrays 

                // set by stopRecording(), undefined by saveRecording(), discardRecording()
                currentRecording = undefined;

                // set by onPlayRecording()
                recordingChannelIndices = undefined;
            }

            restoreOtherHostControlDivs();

            restoreRecordingsDiv();

            restoreHostAndSynthSettings();

            restoreHostGlobalRecordingVariables();
        },

        // exported
        onsaveRecordingButtonInputClicked = function()
        {
            function getStringArray(messages)
            {
                let rval = [],
                    nMessages = messages.length;

                for(let i = 0; i < nMessages; i++)
                {
                    let message = messages[i],
                        msg = message.msg,
                        msPositionReRecording = message.msPositionReRecording,
                        msg2String = (msg[2] === undefined) ? "0" : msg[2].toString(),
                        str = msg[0].toString() + "," + msg[1].toString() + "," + msg2String + "," + msPositionReRecording.toString();

                    rval.push(str);
                }
                return rval;
            }

            console.assert(currentRecording != undefined); // should be set in onstopRecordingButtonInputClick()

            let channelInfos = currentRecording.channels;

            for(let infoIndex = 0; infoIndex < channelInfos.length; infoIndex++)
            {
                let channelInfo = channelInfos[infoIndex];
                channelInfo.messages = getStringArray(channelInfo.messages);
            }

            const a = document.createElement("a");
            a.href = URL.createObjectURL(new Blob([JSON.stringify(currentRecording, null, "\t")], {
                type: "text/plain"
            }));
            a.setAttribute("download", currentRecording.name);
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            restoreStateAfterRecording(); // calls setPerformanceGUIState1();
        },

        // exported
        ondiscardRecordingButtonInputClicked = function()
        {
            restoreStateAfterRecording(); // calls setPerformanceGUIState1();
        },

        getRecordingButtons = function()
        {
            let playRecordingButtonInput = getElem("playRecordingButtonInput"),
                cancelPlaybackButtonInput = getElem("cancelPlaybackButtonInput"),
                startRecordingButtonInput = getElem("startRecordingButtonInput"),
                stopRecordingButtonInput = getElem("stopRecordingButtonInput"),
                saveRecordingButtonInput = getElem("saveRecordingButtonInput"),
                discardRecordingButtonInput = getElem("discardRecordingButtonInput"),
                buttons = {};

            buttons.playRecordingButtonInput = playRecordingButtonInput;
            buttons.cancelPlaybackButtonInput = cancelPlaybackButtonInput;
            buttons.startRecordingButtonInput = startRecordingButtonInput;
            buttons.stopRecordingButtonInput = stopRecordingButtonInput;
            buttons.saveRecordingButtonInput = saveRecordingButtonInput;
            buttons.discardRecordingButtonInput = discardRecordingButtonInput;

            return buttons;
        },

        // State 1 = The initial state
        // (playSelectedRecording, startRecording)
        setPerformanceGUIState1 = function()
        {
            let b = getRecordingButtons();

            b.cancelPlaybackButtonInput.style.display = "none";
            b.discardRecordingButtonInput.style.display = "none";
            b.stopRecordingButtonInput.style.display = "none";
            b.saveRecordingButtonInput.style.display = "none";

            b.playRecordingButtonInput.style.display = "block";
            b.playRecordingButtonInput.value = "play selected recording";
            b.playRecordingButtonInput.style.background = "none";
            b.startRecordingButtonInput.style.display = "block";
            b.startRecordingButtonInput.disabled = false;
        },

        // State 2 = State 1 + playRecordingButtonInput clicked
        // ("cancelPlayback, startRecording disabled")
        setPerformanceGUIState2 = function()
        {
            let b = getRecordingButtons();

            b.playRecordingButtonInput.style.display = "none";
            b.discardRecordingButtonInput.style.display = "none";
            b.stopRecordingButtonInput.style.display = "none";
            b.saveRecordingButtonInput.style.display = "none";

            b.cancelPlaybackButtonInput.style.display = "block";
            b.startRecordingButtonInput.style.display = "block";
            b.startRecordingButtonInput.disabled = true;
        },
        // State 3 = State 1 + startRecordingButtonInput clicked
        // (playSelected, stopRecording)
        setPerformanceGUIState3 = function()
        {
            let b = getRecordingButtons();

            b.cancelPlaybackButtonInput.style.display = "none";
            b.discardRecordingButtonInput.style.display = "none";
            b.startRecordingButtonInput.style.display = "none";
            b.saveRecordingButtonInput.style.display = "none";

            b.playRecordingButtonInput.style.display = "block";
            b.playRecordingButtonInput.value = "play selected recording";
            b.playRecordingButtonInput.style.background = "none";
            b.stopRecordingButtonInput.style.display = "block";
            b.stopRecordingButtonInput.disabled = false;
        },

        // State 4 = State 3 + playRecordingButtonInput clicked
        // (cancelPlayback, stopRecording disabled)
        setPerformanceGUIState4 = function()
        {
            let b = getRecordingButtons();

            b.playRecordingButtonInput.style.display = "none";
            b.discardRecordingButtonInput.style.display = "none";
            b.startRecordingButtonInput.style.display = "none";
            b.saveRecordingButtonInput.style.display = "none";

            b.cancelPlaybackButtonInput.style.display = "block";
            b.stopRecordingButtonInput.style.display = "block";
            b.stopRecordingButtonInput.disabled = true;
        },

        // State 5 = State 3 + stopRecordingButtonInput clicked
        // (playCurrent, discardRecording, saveRecording)
        setPerformanceGUIState5 = function()
        {
            let b = getRecordingButtons();

            b.cancelPlaybackButtonInput.style.display = "none";
            b.startRecordingButtonInput.style.display = "none";
            b.stopRecordingButtonInput.style.display = "none";

            b.playRecordingButtonInput.style.display = "block";
            b.playRecordingButtonInput.value = "play current recording";
            b.playRecordingButtonInput.style.background = "#DFD";
            b.discardRecordingButtonInput.style.display = "block";
            b.discardRecordingButtonInput.disabled = false;
            b.saveRecordingButtonInput.style.display = "block";
            b.saveRecordingButtonInput.disabled = false;
        },

        // State 6 = State 5 + playRecordingButtonInput clicked
        // ("cancelPlayback, discardRecording disabled, saveRecording disabled")
        setPerformanceGUIState6 = function()
        {
            let b = getRecordingButtons();

            b.playRecordingButtonInput.style.display = "none";
            b.startRecordingButtonInput.style.display = "none";
            b.stopRecordingButtonInput.style.display = "none";

            b.cancelPlaybackButtonInput.style.display = "block";
            b.discardRecordingButtonInput.style.display = "block";
            b.discardRecordingButtonInput.disabled = true;
            b.saveRecordingButtonInput.style.display = "block";
            b.saveRecordingButtonInput.disabled = true;
        },

        // exported
        // This application can only record on a single channel.
        // It can, however play back multi-channel recordings - even while recording.
        onstartRecordingButtonInputClicked = function()
        {
            function getCurrentSettings(channelSelectOptions)
            {
                let currentSettings = [];

                for(var channelIndex = 0; channelIndex < 16; channelIndex++)
                {
                    let channelSettings = structuredClone(channelSelectOptions[channelIndex].hostSettings);

                    currentSettings.push(channelSettings);
                }

                return currentSettings;
            }

            function getEmptyRecordedMessagesArray()
            {
                let emptyRecordedMessages = [];

                for(var channelIndex = 0; channelIndex < 16; channelIndex++)
                {
                    emptyRecordedMessages.push([]);
                }
                return emptyRecordedMessages;
            }

            function disableOtherHostControlDivs()
            {
                let presetSettingsDiv = getElem("presetSettingsDiv"),
                    channelPressureDiv = getElem("channelPressureDiv"),
                    keyboardSplitDiv = getElem("keyboardSplitDiv"),
                    settingsSelect = getElem("settingsSelect");

                setDivDisabled(presetSettingsDiv, true);
                setDivDisabled(channelPressureDiv, true);
                setDivDisabled(keyboardSplitDiv, true);
            }

            let channelSelect = getElem("channelSelect");

            // set globals
            settingsBeforeRecording = getCurrentSettings(channelSelect.options); // array (16 channels)
            recordedMessages = getEmptyRecordedMessagesArray(); // array (16 channels)

            // can't change channel manually while recording
            channelSelect.disabled = true;
            disableOtherHostControlDivs();

            setPerformanceGUIState3();
        },

        // exported
        onstopRecordingButtonInputClicked = function()
        {
            function recordedMessagesExist(recordedMessages)
            {
                let theyExist = false;

                if(recordedMessages !== undefined)
                {
                    for(let channelIndex = 0; channelIndex < 16; channelIndex++)
                    {
                        if(recordedMessages[channelIndex].length > 0)
                        {
                            theyExist = true;
                            break;
                        }
                    }
                }

                return theyExist;
            }

            // Moves the time origin to 0, and rounds each value to the nearest integer.
            // Truncates each channel, so that the final message is a NoteOff (i.e removes trailing control messages)
            function normalizeMsPositionReRecordingValues(recordedMessages)
            {
                let NOTE_ON = ResSynth.constants.COMMAND.NOTE_ON,
                    NOTE_OFF = ResSynth.constants.COMMAND.NOTE_OFF,
                    timeOrigin = Number.MAX_VALUE;

                console.assert(recordedMessages.length === 16);

                for(let channelIndex = 0; channelIndex < 16; channelIndex++)
                {
                    let channelMessages = recordedMessages[channelIndex];
                    if(channelMessages.length > 0)
                    {
                        let firstMessage = channelMessages[0];

                        timeOrigin = (firstMessage.msPositionReRecording < timeOrigin) ? firstMessage.msPositionReRecording : timeOrigin;
                    }
                }

                for(let channelIndex = 0; channelIndex < 16; channelIndex++)
                {
                    let channelMessages = recordedMessages[channelIndex];

                    if(channelMessages.length > 0)
                    {
                        for(var msgIndex = channelMessages.length - 1; msgIndex >= 0; msgIndex--)
                        {
                            let command = channelMessages[msgIndex].msg[0] & 0xF0;

                            if(command === NOTE_ON || command === NOTE_OFF)
                            {
                                break;
                            }
                            else
                            {
                                channelMessages.pop();
                            }
                        }

                        for(var messageIndex = 0; messageIndex < channelMessages.length; messageIndex++)
                        {
                            let message = channelMessages[messageIndex];

                            message.msPositionReRecording = Math.round(message.msPositionReRecording - timeOrigin);
                        }
                    }
                }

                return recordedMessages;
            }

            // Returns the currentRecording in the format used in presetRecordings, so that it can easily be
            // played by onplayRecordingButtonInputClicked() and onsaveRecordingButtonInputClicked().
            // Resets the global settingsBeforeRecording and recordedMessages to undefined.
            function getCurrentRecording(settingsBeforeRecording, recordedMessages)
            {
                // returns a non-sparse array containing only the channels that nave messages
                function getChannelInfos(settingsBeforeRecording, recordedMessages)
                {
                    let channelInfos = [];

                    for(var channelIndex = 0; channelIndex < 16; channelIndex++)
                    {
                        if(recordedMessages[channelIndex].length > 0)
                        {
                            let channelInfo = {};

                            channelInfo.channel = channelIndex;
                            channelInfo.channelSettings = settingsBeforeRecording[channelIndex];
                            channelInfo.messages = recordedMessages[channelIndex];

                            channelInfos.push(channelInfo);
                        }
                    }

                    return channelInfos;
                }

                function getName(channelInfos)
                {
                    let fileName = undefined;
                    if(channelInfos.length === 1)
                    {
                        fileName = "ch" + channelInfos[0].channel.toString() + "_recording.json"
                    }
                    else
                    {
                        let channelsStr = "";
                        for(let i = 0; i < channelInfos.length; i++)
                        {
                            channelsStr = channelsStr + channelInfos[i].channel.toString() + ",";
                        }
                        channelsStr = channelsStr.slice(0, channelsStr.length - 1);
                        fileName = "chs" + channelsStr + "_recording.json";
                    }
                    return fileName;
                }

                console.assert(settingsBeforeRecording.length === 16 && recordedMessages.length === 16)

                let currentRecording = {},
                    channelInfos = getChannelInfos(settingsBeforeRecording, recordedMessages),
                    name = getName(channelInfos);

                currentRecording.name = name;
                currentRecording.channels = channelInfos;

                return currentRecording;
            }

            if(cancelPlayback === false && recordedMessagesExist(recordedMessages))
            {
                normalizeMsPositionReRecordingValues(recordedMessages);

                currentRecording = getCurrentRecording(settingsBeforeRecording, recordedMessages);

                settingsBeforeRecording = undefined;
                recordedMessages = undefined;

                setPerformanceGUIState5();
            }
            else
            {
                restoreStateAfterRecording(); // calls setPerformanceGUIState1()
            }
        },

        onKeyboardSplitSelectChanged = function()
        {
            let keyboardSplitIndex = getElem("keyboardSplitSelect").selectedIndex;

            currentChannelPerKeyArray = channelPerKeyArrays[keyboardSplitIndex];
        },

        onChannelPressureSelectChanged = function()
        {
            let channelPressureSelect = getElem("channelPressureSelect");

            globalChannelPressureType = channelPressureSelect.options[channelPressureSelect.selectedIndex].value;
        },

        onOrnamentsSelectChanged = function()
        {
            let channelSelect = getElem("channelSelect"),
                channel = channelSelect.selectedIndex,
                cmdControl = ResSynth.constants.COMMAND.CONTROL_CHANGE + channel,
                CTL = ResSynth.constants.CONTROL,
                hostChannelSettings = channelSelect.options[channel].hostSettings,
                ornamentsSelect = getElem("ornamentsSelect"),
                keyboardOrnamentsArrayIndex = ornamentsSelect.selectedIndex;

            hostChannelSettings.keyboardOrnamentsArrayIndex = keyboardOrnamentsArrayIndex;

            let keyboardOrnamentsArrayIndexMsg = new Uint8Array([cmdControl, CTL.SET_KEYBOARD_ORNAMENT_DEFS, keyboardOrnamentsArrayIndex]);
            sendMessage(keyboardOrnamentsArrayIndexMsg, channel);
        },

        // exported
        onContinueAtStartClicked = function()
        {
            function setPage2Display(synth)
            {
                // called by both commands and CCs
                function getBasicLongInputControl(tr, name, defaultValue, infoString)
                {
                    function getLongControlValue()
                    {
                        return this.rangeInputElem.valueAsNumber;
                    }

                    function getInputElemValue()
                    {
                        return this.valueAsNumber;
                    }

                    // sets synth and channel GUI state
                    function setLongControlValue(value)
                    {
                        this.rangeInputElem.value = value;
                        this.numberInputElem.value = value;

                        setHostSettingsFromLongControl(this, value);

                        this.numberInputElem.onchange();
                    }

                    let nameStrTD = document.createElement("td");
                    tr.appendChild(nameStrTD);
                    nameStrTD.className = "alignRight";
                    nameStrTD.innerHTML = name;

                    // this td contains the slider, number and button inputs
                    let longControlTD = document.createElement("td");
                    longControlTD.id = name + "LongControl";
                    tr.appendChild(longControlTD);

                    let rangeInputElem = document.createElement("input"),
                        numberInputElem = document.createElement("input");

                    rangeInputElem.getValue = getInputElemValue;
                    //rangeInputElem.onchange = "ResSynth.host.onLongControlComponentChanged()"; -- is set later
                    numberInputElem.getValue = getInputElemValue;
                    //numberInputElem.onchange = "ResSynth.host.onLongControlComponentChanged()"; -- is set later

                    longControlTD.appendChild(rangeInputElem);
                    longControlTD.appendChild(numberInputElem);

                    longControlTD.rangeInputElem = rangeInputElem;
                    longControlTD.numberInputElem = numberInputElem;

                    longControlTD.getValue = getLongControlValue;
                    longControlTD.setValue = setLongControlValue;

                    // slider input                        
                    rangeInputElem.type = "range";
                    rangeInputElem.className = "rangeInput"; // see sliderStyleSheet.css
                    rangeInputElem.id = name + "RangeInput"; // Never reference this id! This definition is just to keep Chrome happy. Only ever use longControlTD.id, defined above.
                    rangeInputElem.twinInputElem = numberInputElem;
                    rangeInputElem.value = defaultValue;
                    rangeInputElem.defaultValue = defaultValue;
                    rangeInputElem.min = 0;
                    rangeInputElem.max = 127;

                    // number input                        
                    numberInputElem.type = "number";
                    numberInputElem.className = "numberInput";
                    numberInputElem.id = name + "NumberInput"; // Never reference this id! This definition is just to keep Chrome happy. Only ever use longControlTD.id, defined above.
                    numberInputElem.twinInputElem = rangeInputElem;
                    numberInputElem.value = defaultValue;
                    numberInputElem.defaultValue = defaultValue;
                    numberInputElem.min = 0;
                    numberInputElem.max = 127;

                    let infoTD = document.createElement("td");
                    tr.appendChild(infoTD);
                    infoTD.innerHTML = infoString;

                    return longControlTD;
                }

                function setChannelsDiv()
                {
                    let channelSelect = getElem("channelSelect"),
                        options = channelSelect.options;

                    for(var channel = 0; channel < options.length; channel++)
                    {
                        options[channel].hostSettings = new ResSynth.channelSettings.ChannelSettings();
                    }
                }

                function setBankSelect(bankSelect)
                {
                    function getBankOptions(banks)
                    {
                        let options = [];

                        for(let bankIndex = 0; bankIndex < banks.length; bankIndex++)
                        {
                            let option = new Option("bankOption"),
                                bank = banks[bankIndex],
                                presets = bank.presets,
                                presetOptionsArray = [];

                            for(let presetIndex = 0; presetIndex < presets.length; presetIndex++)
                            {
                                let preset = presets[presetIndex],
                                    presetOption = new Option("presetOption");

                                presetOption.innerHTML = preset.name;
                                presetOption.preset = preset;
                                presetOption.preset.mixtureIndex = 0;

                                presetOptionsArray.push(presetOption);
                            }


                            option.innerHTML = bank.name;
                            option.soundFont = bank;
                            option.presetOptionsArray = presetOptionsArray; // used to set the presetSelect
                            option.url = "https://github.com/surikov/webaudiofont";

                            options.push(option);
                        }

                        return options;
                    }

                    let bankOptions = getBankOptions(synth.webAudioFont);

                    setOptions(bankSelect, bankOptions);

                    bankSelect.selectedIndex = 0;
                }

                function setPresetSelect(presetSelect, bankSelect)
                {
                    setOptions(presetSelect, bankSelect[bankSelect.selectedIndex].presetOptionsArray);

                    presetSelect.selectedIndex = 0;
                }

                function setMixtureSelect(mixtureSelect)
                {
                    function getMixtureOptions()
                    {
                        let mixtures = synth.mixtures,
                            options = [];

                        console.assert(mixtures.length < 127);

                        if(mixtures.length === 0)
                        {
                            let option = new Option("mixtureOption");
                            option.innerHTML = "no mixtures defined";
                            options.push(option);
                        }
                        else
                        {
                            for(let mixtureIndex = 0; mixtureIndex < mixtures.length; mixtureIndex++)
                            {
                                let option = new Option("mixtureOption");

                                option.innerHTML = mixtures[mixtureIndex].name;

                                options.push(option);
                            }
                        }

                        return options;
                    }

                    let mixtureOptions = getMixtureOptions();

                    setOptions(mixtureSelect, mixtureOptions);

                    mixtureSelect.selectedIndex = 0;
                }

                function setTuningGroupSelect(tuningGroupSelect)
                {
                    function getTuningGroupOptions(tuningGroups)
                    {
                        let options = [];

                        for(let i = 0; i < tuningGroups.length; i++)
                        {
                            let tuningGroupOption = new Option("tuningGroupOption"),
                                tuningGroup = tuningGroups[i],
                                tuningOptionsArray = [];

                            for(let j = 0; j < tuningGroup.length; j++)
                            {
                                let tuningOption = new Option("tuningOption");

                                tuningOption.innerHTML = tuningGroup[j].name;
                                tuningOptionsArray.push(tuningOption);
                            }

                            if(tuningGroup.name === undefined) // missing tuningDefs.js file
                            {
                                let tuningGroupSelect = getElem("tuningGroupSelect");

                                tuningGroupOption.innerHTML = "no tuning groups defined";
                                tuningGroupSelect.disabled = true;
                            }
                            else
                            {
                                tuningGroupOption.innerHTML = tuningGroup.name;
                            }

                            tuningGroupOption.tuningGroup = tuningGroup;
                            tuningGroupOption.tuningOptionsArray = tuningOptionsArray; // used to set the tuningSelect

                            options.push(tuningGroupOption);
                        }

                        return options;
                    }

                    let tuningGroupOptions = getTuningGroupOptions(synth.tuningGroups);
                    setOptions(tuningGroupSelect, tuningGroupOptions);
                    tuningGroupSelect.selectedIndex = 0;
                }

                function setTuningSelect()
                {
                    function appendTuningSelect(tuningSelectCell, tuningOptionsArray)
                    {
                        var tuningSelect;

                        tuningSelect = document.createElement("select");
                        tuningSelect.id = "tuningSelect";
                        tuningSelect.className = "tuningSelect";
                        setOptions(tuningSelect, tuningOptionsArray);
                        tuningSelect.onchange = onTuningSelectChanged;
                        tuningSelectCell.appendChild(tuningSelect);
                    }

                    let tuningGroupSelect = getElem("tuningGroupSelect"),
                        tuningSelectCell = getElem("tuningSelectCell"),
                        tuningOptionsArray = tuningGroupSelect[tuningGroupSelect.selectedIndex].tuningOptionsArray;

                    appendTuningSelect(tuningSelectCell, tuningOptionsArray);
                }

                function setSemitonesAndCentsControls()
                {
                    function getMidiValue(controlValue)
                    {
                        return controlValue + 64;
                    }

                    let semitonesOffsetNumberInput = getElem("semitonesOffsetNumberInput"),
                        centsOffsetNumberInput = getElem("centsOffsetNumberInput");

                    semitonesOffsetNumberInput.midiValue = getMidiValue;
                    centsOffsetNumberInput.midiValue = getMidiValue;
                }

                function setHostSettingsFromLongControl(longControl, value)
                {
                    let channel = getElem("channelSelect").selectedIndex,
                        hostChannelSettings = channelSelect.options[channel].hostSettings;

                    if(hostChannelSettings !== undefined)
                    {
                        let longControlID = longControl.id;

                        switch(longControlID)
                        {
                            case "pitchWheelLongControl":
                                hostChannelSettings.pitchWheel = value;
                                break;
                            case "modWheelLongControl":
                                hostChannelSettings.modWheel = value;
                                break;
                            case "volumeLongControl":
                                hostChannelSettings.volume = value;
                                break;
                            case "expressionLongControl":
                                hostChannelSettings.expression = value;
                                break;
                            case "panLongControl":
                                hostChannelSettings.pan = value;
                                break;
                            case "reverberationLongControl":
                                hostChannelSettings.reverberation = value;
                                break;
                            case "pitchWheelSensitivityLongControl":
                                hostChannelSettings.pitchWheelSensitivity = value;
                                break;
                            case "velocityPitchSensitivityLongControl":
                                hostChannelSettings.velocityPitchSensitivity = value;
                                break;
                            default:
                                console.assert(false, "Unknown long control");
                                break;
                        }
                    }
                }

                function setCommandsAndControlsDivs()
                {
                    function setCommandsAndControlsTable()
                    {
                        function getCommandRows()
                        {
                            function getCommandInfos()
                            {
                                function getStandardCommandInfo(constants, cmdIndex)
                                {
                                    let info = {};

                                    info.name = constants.commandName(cmdIndex);
                                    info.defaultValue = constants.commandDefaultValue(cmdIndex);
                                    info.cmdIndex = cmdIndex;
                                    info.cmdString = "CMD " + cmdIndex.toString();

                                    return info;
                                }

                                let constants = ResSynth.constants,
                                    cmd = constants.COMMAND,
                                    pitchWheel = getStandardCommandInfo(constants, cmd.PITCHWHEEL),
                                    commandInfos = [];

                                commandInfos.push(pitchWheel);

                                return commandInfos;
                            }

                            function setCommandRow(tr, name, defaultValue, cmdIndex, cmdString)
                            {
                                function baseSendCommand(cmdIndex, value)
                                {
                                    if(cmdIndex === ResSynth.constants.COMMAND.PITCHWHEEL)
                                    {
                                        // Note that:
                                        // 1. This function is called by the GUI controls, not by the EMU keyboard.
                                        // 2. The EMU keyboard generates different data1 values for the corresponding data2 values.
                                        // 3. The data1 values calculated here are such that
                                        //     a) if data2 is 64, data1 is 0.(MIDI Standard, same as EMU keyboard)
                                        //     b) data2 values are (differently) equidistant above and below data2=64.
                                        let data1 = 0,
                                            data2 = value; // default (for value === 64)

                                        if(data2 > 64)
                                        {
                                            data1 = data2;
                                        }
                                        else if(data2 < 64)
                                        {
                                            data1 = data2 * 2; // data1 is in range 0..126 for data2 0..63
                                        }

                                        //console.log("d1=" + data1 + " d2=" + data2);
                                        let msg = new Uint8Array([cmdIndex + currentChannel, data1, data2]);
                                        sendMessage(msg, currentChannel);
                                    }
                                    else
                                    {
                                        // can only be PITCHWHEEL
                                        console.assert(false, "Error");
                                    }
                                }
                                function onCommandInputChanged(event)
                                {
                                    var target = (event === undefined) ? this : event.currentTarget,
                                        value = target.valueAsNumber,
                                        cmdIndex = target.cmdIndex;

                                    target.twinInputElem.value = value;

                                    setHostSettingsFromLongControl(target.parentElement, value);

                                    baseSendCommand(cmdIndex, value);
                                }

                                let longInputControlTD = getBasicLongInputControl(tr, name, defaultValue, cmdString);

                                longInputControlTD.cmdIndex = cmdIndex;
                                longInputControlTD.rangeInputElem.cmdIndex = cmdIndex;
                                longInputControlTD.numberInputElem.cmdIndex = cmdIndex;
                                longInputControlTD.rangeInputElem.onchange = onCommandInputChanged;
                                longInputControlTD.numberInputElem.onchange = onCommandInputChanged;

                                allLongInputControls.push(longInputControlTD);
                            }

                            let rval = [],
                                commandInfos = getCommandInfos();

                            for(let i = 0; i < commandInfos.length; ++i)
                            {
                                let commandInfo = commandInfos[i],
                                    name = commandInfo.name,
                                    defaultValue = commandInfo.defaultValue,
                                    cmdIndex = commandInfo.cmdIndex,
                                    cmdString = commandInfo.cmdString;

                                let tr = document.createElement("tr");
                                rval.push(tr);
                                setCommandRow(tr, name, defaultValue, cmdIndex, cmdString);
                            }

                            return rval;
                        }
                        // returns an array of tr elements
                        function getControlRows()
                        {
                            // 3-byte controls
                            function setLongControlRow(tr, name, defaultValue, ccIndex, regParam, ccString)
                            {
                                function onControlInputChanged(event)
                                {
                                    var target = (event === undefined) ? this : event.currentTarget,
                                        value = target.valueAsNumber,
                                        ccIndex = target.ccIndex;

                                    target.twinInputElem.value = value;

                                    setHostSettingsFromLongControl(target.parentElement, value);

                                    sendLongControl(ccIndex, value);
                                }

                                let longInputControlTD = getBasicLongInputControl(tr, name, defaultValue, ccString);

                                console.assert(ccIndex !== undefined);

                                longInputControlTD.ccIndex = ccIndex;
                                longInputControlTD.rangeInputElem.ccIndex = ccIndex;
                                longInputControlTD.numberInputElem.ccIndex = ccIndex;

                                longInputControlTD.rangeInputElem.onchange = onControlInputChanged;
                                longInputControlTD.numberInputElem.onchange = onControlInputChanged;

                                allLongInputControls.push(longInputControlTD);
                            }

                            // 2-byte uControls
                            function setShortControlRow(tr, name, ccIndex, ccString)
                            {
                                var
                                    button,
                                    td = document.createElement("td");

                                function onSendShortControlButtonClick(event)
                                {
                                    sendShortControl(event.currentTarget.ccIndex);
                                }

                                tr.appendChild(td);
                                td.className = "alignRight";
                                td.innerHTML = name;

                                td = document.createElement("td");
                                tr.appendChild(td);
                                button = document.createElement("input");
                                button.type = "button";
                                button.className = "sendButtonInput";
                                button.value = "send";
                                button.ccIndex = ccIndex;
                                button.onclick = onSendShortControlButtonClick;
                                td.appendChild(button);

                                let node = document.createTextNode(ccString);
                                td.appendChild(node);
                            }

                            function getControlInfos()
                            {
                                function getStandardControlInfo(constants, ccIndex)
                                {
                                    let info = {};

                                    info.name = constants.controlName(ccIndex);
                                    info.defaultValue = constants.controlDefaultValue(ccIndex);
                                    info.ccIndex = ccIndex;
                                    info.ccString = "CC " + ccIndex.toString();

                                    return info;
                                }

                                let constants = ResSynth.constants,
                                    ctl = constants.CONTROL,
                                    modWheelData = getStandardControlInfo(constants, ctl.MODWHEEL),
                                    volumeData = getStandardControlInfo(constants, ctl.VOLUME),
                                    expressionData = getStandardControlInfo(constants, ctl.EXPRESSION),
                                    panData = getStandardControlInfo(constants, ctl.PAN),
                                    reverberationData = getStandardControlInfo(constants, ctl.REVERBERATION),
                                    pitchWheelSensitivityData = getStandardControlInfo(constants, ctl.PITCH_WHEEL_SENSITIVITY),
                                    velocityPitchSensitivityData = getStandardControlInfo(constants, ctl.VELOCITY_PITCH_SENSITIVITY),
                                    allControllersOff = getStandardControlInfo(constants, ctl.ALL_CONTROLLERS_OFF),
                                    allSoundOff = getStandardControlInfo(constants, ctl.ALL_SOUND_OFF),
                                    controlInfos = [];

                                controlInfos.push(modWheelData);
                                controlInfos.push(volumeData);
                                controlInfos.push(expressionData);
                                controlInfos.push(panData);
                                controlInfos.push(reverberationData);
                                controlInfos.push(pitchWheelSensitivityData);
                                controlInfos.push(velocityPitchSensitivityData);
                                controlInfos.push(allSoundOff);
                                controlInfos.push(allControllersOff);

                                return controlInfos;
                            }

                            let rval = [],
                                controlInfos = getControlInfos();

                            for(let i = 0; i < controlInfos.length; ++i)
                            {
                                let c = ResSynth.constants,
                                    control = c.CONTROL,
                                    controlInfo = controlInfos[i],
                                    name = controlInfo.name,
                                    defaultValue = controlInfo.defaultValue,
                                    ccIndex = controlInfo.ccIndex,
                                    regParam = controlInfo.regParam, // can be undefined
                                    ccString = controlInfo.ccString,
                                    tr = document.createElement("tr");

                                rval.push(tr);

                                if(ccIndex === control.ALL_CONTROLLERS_OFF)
                                {
                                    name = name + " (set defaults)";
                                    setShortControlRow(tr, name, ccIndex, ccString);
                                }
                                else if(ccIndex === control.ALL_SOUND_OFF)
                                {
                                    setShortControlRow(tr, name, ccIndex, ccString);
                                }
                                else
                                {
                                    setLongControlRow(tr, name, defaultValue, ccIndex, regParam, ccString);
                                }
                            }

                            return rval;
                        }

                        let commandsAndControlsTable = getElem("commandsAndControlsTable"),
                            commandRows = getCommandRows(),
                            controlRows = getControlRows();

                        for(let i = 0; i < commandRows.length; ++i)
                        {
                            let tr = commandRows[i];
                            commandsAndControlsTable.appendChild(tr);
                        }

                        for(let i = 0; i < controlRows.length; ++i)
                        {
                            let tr = controlRows[i];
                            commandsAndControlsTable.appendChild(tr);
                        }
                    }

                    allLongInputControls.length = 0;

                    setCommandsAndControlsTable();

                    sendShortControl(ResSynth.constants.CONTROL.ALL_CONTROLLERS_OFF);
                }

                function setOrnamentsDiv()
                {
                    function setKeyOrnamentsSelect()
                    {
                        let ornamentsSelect = getElem("ornamentsSelect"),
                            ornamentPerKeysStrings = ResSynth.ornamentPerKeysStrings;

                        let option = new Option();

                        option.innerHTML = "none";
                        ornamentsSelect.options.add(option);

                        if(ornamentPerKeysStrings !== undefined)
                        {
                            for(let i = 0; i < ornamentPerKeysStrings.length; i++)
                            {
                                let option = new Option();

                                option.innerHTML = ornamentPerKeysStrings[i];
                                ornamentsSelect.options.add(option);
                            }
                        }

                        ornamentsSelect.selectedIndex = 0;
                    }

                    setKeyOrnamentsSelect();
                }

                function setHostSettingsDiv()
                {
                    function setChannelPressureDiv()
                    {
                        // see onControlInputChanged() in setLongControlRow(...) below
                        function onChannelPressureSensitivityLongControlChanged(event)
                        {
                            var target = (event === undefined) ? this : event.currentTarget,
                                value = target.valueAsNumber;

                            target.twinInputElem.value = value;

                            globalChannelPressureFactor = value / 127;
                        }

                        let tr = getElem("channelPressureTR"),
                            defaultValue = 64,
                            channelPressureSensitivityLongControl = getBasicLongInputControl(tr, "sensitivity", defaultValue, "");

                        globalChannelPressureFactor = defaultValue / 127;

                        channelPressureSensitivityLongControl.rangeInputElem.style.width = "256px";
                        tr.removeChild(tr.lastChild);
                        tr.lastChild.style.paddingRight = "0";

                        channelPressureSensitivityLongControl.rangeInputElem.onchange = onChannelPressureSensitivityLongControlChanged;
                        channelPressureSensitivityLongControl.numberInputElem.onchange = onChannelPressureSensitivityLongControlChanged;
                    }
                    function setKeyboardSplitDiv()
                    {
                        let keyboardSplitSelect = getElem("keyboardSplitSelect");

                        // this option is always added by default to index 0
                        let option = new Option();
                        option.innerHTML = "no split (messages will be sent on the current channel)";
                        keyboardSplitSelect.options.add(option);

                        if(ResSynth.keyboardSplitDefs !== undefined)
                        {
                            let keyboardSplitDefs = ResSynth.keyboardSplitDefs;

                            for(let i = 0; i < keyboardSplitDefs.length; i++)
                            {
                                let keyboardSplitDef = keyboardSplitDefs[i],
                                    option = new Option();

                                option.innerHTML = keyboardSplitDef;
                                keyboardSplitSelect.options.add(option);
                            }
                        }

                        keyboardSplitSelect.selectedIndex = 0;
                    }
                    function setPresetSettingsDiv()
                    {
                        // Converts the information in synthSettingsDefs.js into the (private) settingsChangePerSection.
                        // Returns an array of sectionSettings, each of which contains an array of channelSettings (one per used channel).
                        // The first sectionSettings object contains channelSettings that contain a full set of attributes.
                        // ChannelSettings in subsequent sections contain only the attributes and values that differ from
                        // the corresponding channelSetting in the previous section.
                        // N.B. _comment attributes in the synthSettingsDefs.js file are completely ignored by the host,
                        // so can be added and freely edited as required.
                        // The exportSettingsButtonClick() function writes similar _comment attributes automatically.
                        function getSettingsChangePerSection(synthSettingsDefs)
                        {
                            function checkArray(attributeName, array, length)
                            {
                                if(!Array.isArray(array) || (array.length !== length))
                                {
                                    let errorString = `Error in synthSettingsDefs.js:\n` +
                                        `synthSettingsDefs.${attributeName} must be defined, and must have the same length as\n` +
                                        `the "names" attribute (${length}).`;
                                    throwError(errorString);
                                }
                            }

                            function checkTopLevelAttributes(names, keyboardSplitIndexes)
                            {
                                function checkNames(names, arrayLength)
                                {
                                    checkArray("names", names, arrayLength);

                                    for(let i = 0; i < names.length; i++)
                                    {
                                        let name = names[i];
                                        if((typeof name === 'string' || name instanceof String) === false)
                                        {
                                            throwError("All synthSettingsDefs.names must be strings.")
                                        }
                                    }
                                }

                                function checkKeyboardSplitIndexValues(keyboardSplitIndexes, arrayLength)
                                {
                                    let keyboardSplitDefs = ResSynth.keyboardSplitDefs;

                                    checkArray("keyboardSplitIndexes", keyboardSplitIndexes, arrayLength);

                                    for(let i = 0; i < keyboardSplitIndexes.length; i++)
                                    {
                                        let keyboardSplitIndex = keyboardSplitIndexes[i];

                                        if(!Number.isInteger(keyboardSplitIndex) || (keyboardSplitIndex < 0) || (keyboardSplitIndex >= keyboardSplitDefs.length))
                                        {
                                            throwError(`All synthSettingsDefs.keyboardSplitIndexes must be integers in range 0..${keyboardSplitDefs.length} (keyboardSplitDefs length)`);
                                        }
                                    }
                                }

                                let arrayLength = names.length;

                                checkNames(names, arrayLength);
                                checkKeyboardSplitIndexValues(keyboardSplitIndexes, arrayLength);
                            }

                            function checkChannelSettingsArray(channelSettingsArray, arrayLength)
                            {
                                function checkChannelAttributeArray(channel, attributeName, array, length)
                                {
                                    if(!Array.isArray(array) || (array.length !== length))
                                    {
                                        let errorString = `Error in synthSettingsDefs.js\n` +
                                            `Channel ${channel} ${attributeName} must be defined, and must have the same length as\n` +
                                            `the "names" attribute (${length}).`;

                                        throwError(errorString);
                                    }
                                }

                                for(let channel = 0; channel < channelSettingsArray.length; channel++)
                                {
                                    let channelSettings = channelSettingsArray[channel];

                                    checkChannelAttributeArray(channel, "bankIndex", channelSettings.bankIndex, arrayLength);
                                    checkChannelAttributeArray(channel, "presetIndex", channelSettings.presetIndex, arrayLength);
                                    checkChannelAttributeArray(channel, "mixtureIndex", channelSettings.mixtureIndex, arrayLength);
                                    checkChannelAttributeArray(channel, "tuningGroupIndex", channelSettings.tuningGroupIndex, arrayLength);
                                    checkChannelAttributeArray(channel, "tuningIndex", channelSettings.tuningIndex, arrayLength);
                                    checkChannelAttributeArray(channel, "semitonesOffset", channelSettings.semitonesOffset, arrayLength);
                                    checkChannelAttributeArray(channel, "centsOffset", channelSettings.centsOffset, arrayLength);
                                    checkChannelAttributeArray(channel, "pitchWheel", channelSettings.pitchWheel, arrayLength);
                                    checkChannelAttributeArray(channel, "modWheel", channelSettings.modWheel, arrayLength);
                                    checkChannelAttributeArray(channel, "volume", channelSettings.volume, arrayLength);
                                    checkChannelAttributeArray(channel, "expression", channelSettings.expression, arrayLength);
                                    checkChannelAttributeArray(channel, "pan", channelSettings.pan, arrayLength);
                                    checkChannelAttributeArray(channel, "reverberation", channelSettings.reverberation, arrayLength);
                                    checkChannelAttributeArray(channel, "pitchWheelSensitivity", channelSettings.pitchWheelSensitivity, arrayLength);
                                    checkChannelAttributeArray(channel, "velocityPitchSensitivity", channelSettings.velocityPitchSensitivity, arrayLength);
                                    checkChannelAttributeArray(channel, "keyboardOrnamentsArrayIndex", channelSettings.keyboardOrnamentsArrayIndex, arrayLength);
                                }
                            }

                            function checkChannelSettingsValues(channelSettingsArray)
                            {
                                function getChannelSettingsPerSectionArray(channelSettingsArray)
                                {
                                    let channelSettingsPerSectionArray = [];

                                    for(let channel = 0; channel < channelSettingsArray.length; channel++)
                                    {
                                        let channelAttributesObject = channelSettingsArray[channel],
                                            nSections = channelAttributesObject.bankIndex.length,
                                            channelSections = [];

                                        for(let section = 0; section < nSections; section++)
                                        {
                                            let channelSectionSettings = {};

                                            channelSectionSettings.bankIndex = channelAttributesObject.bankIndex[section];
                                            channelSectionSettings.presetIndex = channelAttributesObject.presetIndex[section];
                                            channelSectionSettings.mixtureIndex = channelAttributesObject.mixtureIndex[section];
                                            channelSectionSettings.tuningGroupIndex = channelAttributesObject.tuningGroupIndex[section];
                                            channelSectionSettings.tuningIndex = channelAttributesObject.tuningIndex[section];
                                            channelSectionSettings.semitonesOffset = channelAttributesObject.semitonesOffset[section];
                                            channelSectionSettings.centsOffset = channelAttributesObject.centsOffset[section];
                                            channelSectionSettings.pitchWheel = channelAttributesObject.pitchWheel[section];
                                            channelSectionSettings.modWheel = channelAttributesObject.modWheel[section];
                                            channelSectionSettings.volume = channelAttributesObject.volume[section];
                                            channelSectionSettings.expression = channelAttributesObject.expression[section];
                                            channelSectionSettings.pan = channelAttributesObject.pan[section];
                                            channelSectionSettings.reverberation = channelAttributesObject.reverberation[section];
                                            channelSectionSettings.pitchWheelSensitivity = channelAttributesObject.pitchWheelSensitivity[section];
                                            channelSectionSettings.velocityPitchSensitivity = channelAttributesObject.velocityPitchSensitivity[section];
                                            channelSectionSettings.keyboardOrnamentsArrayIndex = channelAttributesObject.keyboardOrnamentsArrayIndex[section];

                                            channelSections.push(channelSectionSettings)
                                        }

                                        channelSettingsPerSectionArray.push(channelSections);
                                    }

                                    return channelSettingsPerSectionArray;
                                }

                                function checkValues(channelSettings, sectionIndex)
                                {
                                    function getErrorString(errorString, errorCondition, errorMessage)
                                    {
                                        errorString = (errorCondition) ? errorString.concat(errorMessage, "\n") : errorString;
                                        return errorString;
                                    }

                                    function midiRangeError(value)
                                    {
                                        return (value < 0 || value > 127) ? true : false;
                                    }

                                    function midiErrorMsg(ctlString, value)
                                    {
                                        return `${ctlString} out of range [0..127] (${ctlString}=${value})`;
                                    }

                                    let webAudioFontDef = ResSynth.webAudioFontDef,
                                        mixtureDefs = ResSynth.mixtureDefs,
                                        tuningDefs = ResSynth.tuningDefs,
                                        ornamentDefs = ResSynth.ornamentDefs,
                                        bankIndex = channelSettings.bankIndex,
                                        presetIndex = channelSettings.presetIndex,
                                        mixtureIndex = channelSettings.mixtureIndex,
                                        tuningGroupIndex = channelSettings.tuningGroupIndex,
                                        tuningIndex = channelSettings.tuningIndex,
                                        semitonesOffset = channelSettings.semitonesOffset,
                                        centsOffset = channelSettings.centsOffset,
                                        pitchWheel = channelSettings.pitchWheel,
                                        modWheel = channelSettings.modWheel,
                                        volume = channelSettings.volume,
                                        expression = channelSettings.expression,
                                        pan = channelSettings.pan,
                                        reverberation = channelSettings.reverberation,
                                        pitchWheelSensitivity = channelSettings.pitchWheelSensitivity,
                                        velocityPitchSensitivity = channelSettings.velocityPitchSensitivity,
                                        keyboardOrnamentsArrayIndex = channelSettings.keyboardOrnamentsArrayIndex,
                                        errorString = "";

                                    // N.B. "noMixtures", "noTuningGroup" and "noOrnament" options are inserted before the definitions given in
                                    // ResSynth.mixtureDefs, ResSynth.tuningDefs and ResSynth.ornamentDefs, so the corresponding allowed indexes
                                    // can be as large as the lengths of each of these definitions.
                                    errorString = getErrorString(errorString, webAudioFontDef === undefined, `webAudioFont must be defined.`);
                                    if(bankIndex !== undefined)
                                        errorString = getErrorString(errorString, bankIndex < 0 || bankIndex >= webAudioFontDef.length, `bankIndex out of range (0..${webAudioFontDef.length - 1}).`);
                                    if(presetIndex !== undefined)
                                        errorString = getErrorString(errorString, presetIndex < 0 || presetIndex >= webAudioFontDef[bankIndex].presets.length, `preset out of range in webAudioFontDef bank (bankIndex=${bankIndex}, presetIndex=${presetIndex})`);
                                    if(mixtureIndex !== undefined)
                                    {
                                        errorString = getErrorString(errorString, mixtureIndex < 0, `mixtureIndex must be >= 0`);
                                        errorString = getErrorString(errorString, mixtureDefs === undefined, `mixtureIndex must be >= 0`);
                                        errorString = getErrorString(errorString, mixtureDefs === undefined && mixtureIndex > 0, `mixtureIndex must be 0 if mixtureDefs are not defined.`);
                                        errorString = getErrorString(errorString, mixtureDefs !== undefined && mixtureIndex >= mixtureDefs.length + 1, `mixtureIndex out of range (0..${mixtureDefs.length}): (mixtureIndex=${mixtureIndex})`);
                                    }
                                    if(tuningGroupIndex !== undefined)
                                    {
                                        errorString = getErrorString(errorString, tuningGroupIndex < 0, `tuningGroupIndex must be >= 0`);
                                        errorString = getErrorString(errorString, tuningDefs === undefined && tuningGroupIndex > 0, `tuningGroupIndex must be 0 if tuningDefs are not defined.`);
                                        errorString = getErrorString(errorString, tuningDefs !== undefined && tuningGroupIndex >= tuningDefs.length + 1, `tuningGroupIndex out of range (0..${tuningDefs.length}): (tuningGroupIndex=${tuningGroupIndex})`);
                                    }
                                    if(tuningIndex !== undefined)
                                    {
                                        errorString = getErrorString(errorString, tuningIndex < 0, `tuningIndex must be >= 0`);
                                        if(tuningGroupIndex !== undefined)
                                        {
                                            errorString = getErrorString(errorString, tuningDefs !== undefined && tuningIndex >= tuningDefs[tuningGroupIndex].tunings.length, `tuningIndex out of range (0..${tuningDefs[tuningGroupIndex].tunings.length - 1}): (tuningIndex=${tuningIndex})`);
                                        }
                                    }
                                    if(keyboardOrnamentsArrayIndex !== undefined)
                                    {
                                        errorString = getErrorString(errorString, keyboardOrnamentsArrayIndex < 0, `keyboardOrnamentsArrayIndex must be >= 0`);
                                        errorString = getErrorString(errorString, ornamentDefs === undefined && keyboardOrnamentsArrayIndex > 0, `keyboardOrnamentsArrayIndex must be 0 if ornamentDefs are not defined.`);
                                        errorString = getErrorString(errorString, ornamentDefs !== undefined && keyboardOrnamentsArrayIndex >= ornamentDefs.length + 1, `keyboardOrnamentsArrayIndex out of range (0..${ornamentDefs.length}): (keyboardOrnamentsArrayIndex=${keyboardOrnamentsArrayIndex})`);
                                    }
                                    if(semitonesOffset !== undefined)
                                        errorString = getErrorString(errorString, semitonesOffset < -64 || semitonesOffset > 63, `semitonesOffset out of range [-64..+63] (semitonesOffset=${semitonesOffset})`);
                                    if(centsOffset !== undefined)
                                        errorString = getErrorString(errorString, centsOffset < -50 || centsOffset > 50, `centsOffset out of range [-50..+50] (centsOffset=${centsOffset})`);
                                    if(pitchWheel !== undefined)
                                        errorString = getErrorString(errorString, midiRangeError(pitchWheel), midiErrorMsg("pitchWheel", pitchWheel));
                                    if(modWheel !== undefined)
                                        errorString = getErrorString(errorString, midiRangeError(modWheel), midiErrorMsg("modWheel", modWheel));
                                    if(volume !== undefined)
                                        errorString = getErrorString(errorString, midiRangeError(volume), midiErrorMsg("volume", volume));
                                    if(expression !== undefined)
                                        errorString = getErrorString(errorString, midiRangeError(expression), midiErrorMsg("expression", expression));
                                    if(pan !== undefined)
                                        errorString = getErrorString(errorString, midiRangeError(pan), midiErrorMsg("pan", pan));
                                    if(reverberation !== undefined)
                                        errorString = getErrorString(errorString, midiRangeError(reverberation), midiErrorMsg("reverberation", reverberation));
                                    if(pitchWheelSensitivity !== undefined)
                                        errorString = getErrorString(errorString, midiRangeError(pitchWheelSensitivity), midiErrorMsg("pitchWheelSensitivity", pitchWheelSensitivity));
                                    if(velocityPitchSensitivity !== undefined)
                                        errorString = getErrorString(errorString, midiRangeError(velocityPitchSensitivity), midiErrorMsg("velocityPitchSensitivity", velocityPitchSensitivity));

                                    if(errorString.length > 0)
                                    {
                                        errorString = `Error in synthSettingsDefs.js channelSettingsArray:\n` +
                                            `section index: ${sectionIndex} \n\n` + errorString;
                                        throwError(errorString);
                                    }
                                }

                                let channelSettingsPerSectionArray = getChannelSettingsPerSectionArray(channelSettingsArray),
                                    nChannels = channelSettingsPerSectionArray.length,
                                    nSections = channelSettingsPerSectionArray[0].length;

                                for(let channel = 0; channel < nChannels; channel++)
                                {
                                    let channelSettingsPerSection = channelSettingsPerSectionArray[channel];

                                    for(let sectionIndex = 0; sectionIndex < nSections; sectionIndex++)
                                    {
                                        let channelSettings = channelSettingsPerSection[sectionIndex];

                                        checkValues(channelSettings, sectionIndex);
                                    }
                                }
                            }

                            // See the comment on the surrounding function above.
                            function getSettingsChangePerSect(names, keyboardSplitIndexes, channelSettingsArray)
                            {
                                // returns undefined if the attribute does not need to be set,
                                // otherwise returns valuesArray[settingsIndex].
                                function getNewAttributeValue(attributeValuesArray, sectionIndex)
                                {
                                    let value = attributeValuesArray[sectionIndex];
                                    if(sectionIndex > 0)
                                    {
                                        let prevValue = attributeValuesArray[sectionIndex - 1];

                                        if(value === prevValue)
                                        {
                                            value = undefined;
                                        }
                                    }
                                    return value;
                                }

                                function getChangedChannelSettings(channelSettingsArray, sectionIndex)
                                {
                                    // If sectionIndex === 0, returns a full set of settings,
                                    // otherwise, the returned object contains only the attributes and values
                                    // that are different in the previous section.
                                    function getChangedChanSettings(inChannelSettingsArrays, sectionIndex)
                                    {
                                        function setNewAttributeValue(newChannelSettings, inChannelSettingsArray, attrName, sectionIndex)
                                        {
                                            let attributeValuesArray = inChannelSettingsArray[attrName],
                                                value = getNewAttributeValue(attributeValuesArray, sectionIndex);

                                            // override value in the following two cases
                                            if(attrName === "presetIndex" && newChannelSettings["bankIndex"] !== undefined)
                                            {   // always define presetIndex value, if bankIndex is defined 
                                                value = attributeValuesArray[sectionIndex];
                                            }
                                            else if(attrName === "tuningIndex" && newChannelSettings["tuningGroupIndex"] !== undefined)
                                            {   // always define tuningIndex value, if tuningGroupIndex is defined
                                                value = attributeValuesArray[sectionIndex];
                                            }

                                            if(value !== undefined)
                                            {
                                                newChannelSettings[attrName] = value;
                                            }
                                        }

                                        let newChannelSettings = {};

                                        setNewAttributeValue(newChannelSettings, inChannelSettingsArrays, "bankIndex", sectionIndex),
                                            setNewAttributeValue(newChannelSettings, inChannelSettingsArrays, "presetIndex", sectionIndex),
                                            setNewAttributeValue(newChannelSettings, inChannelSettingsArrays, "mixtureIndex", sectionIndex),
                                            setNewAttributeValue(newChannelSettings, inChannelSettingsArrays, "tuningGroupIndex", sectionIndex),
                                            setNewAttributeValue(newChannelSettings, inChannelSettingsArrays, "tuningIndex", sectionIndex),
                                            setNewAttributeValue(newChannelSettings, inChannelSettingsArrays, "semitonesOffset", sectionIndex),
                                            setNewAttributeValue(newChannelSettings, inChannelSettingsArrays, "centsOffset", sectionIndex),
                                            setNewAttributeValue(newChannelSettings, inChannelSettingsArrays, "pitchWheel", sectionIndex),
                                            setNewAttributeValue(newChannelSettings, inChannelSettingsArrays, "modWheel", sectionIndex),
                                            setNewAttributeValue(newChannelSettings, inChannelSettingsArrays, "volume", sectionIndex),
                                            setNewAttributeValue(newChannelSettings, inChannelSettingsArrays, "expression", sectionIndex),
                                            setNewAttributeValue(newChannelSettings, inChannelSettingsArrays, "pan", sectionIndex),
                                            setNewAttributeValue(newChannelSettings, inChannelSettingsArrays, "reverberation", sectionIndex),
                                            setNewAttributeValue(newChannelSettings, inChannelSettingsArrays, "pitchWheelSensitivity", sectionIndex),
                                            setNewAttributeValue(newChannelSettings, inChannelSettingsArrays, "velocityPitchSensitivity", sectionIndex),
                                            setNewAttributeValue(newChannelSettings, inChannelSettingsArrays, "keyboardOrnamentsArrayIndex", sectionIndex);

                                        return newChannelSettings;
                                    }

                                    let newChannelSettingsArray = [],
                                        nChannels = channelSettingsArray.length;

                                    for(let channel = 0; channel < nChannels; channel++)
                                    {
                                        let inChannelSettingsArrays = channelSettingsArray[channel],
                                            newChannelSettings = getChangedChanSettings(inChannelSettingsArrays, sectionIndex);

                                        newChannelSettingsArray.push(newChannelSettings);
                                    }

                                    return newChannelSettingsArray;
                                }

                                let sectionSettingsArray = [];

                                let nSections = channelSettingsArray[0].bankIndex.length;

                                for(let sectionIndex = 0; sectionIndex < nSections; sectionIndex++)
                                {
                                    let sectionSettings = {},
                                        name = names[sectionIndex],
                                        keyboardSplitIndex = getNewAttributeValue(keyboardSplitIndexes, sectionIndex),
                                        channelSettings = getChangedChannelSettings(channelSettingsArray, sectionIndex);

                                    sectionSettings.name = name;

                                    if(keyboardSplitIndex !== undefined)
                                    {
                                        sectionSettings.keyboardSplitIndex = keyboardSplitIndex;
                                    }

                                    sectionSettings.channelSettings = channelSettings;

                                    sectionSettingsArray.push(sectionSettings);
                                }

                                return sectionSettingsArray;
                            }

                            let settingsChangePerSection = [];

                            if(synthSettingsDefs !== undefined)
                            {
                                let names = synthSettingsDefs.names,
                                    keyboardSplitIndexes = synthSettingsDefs.keyboardSplitIndexes,
                                    channelSettingsArray = synthSettingsDefs.channelSettingsArray;

                                checkTopLevelAttributes(names, keyboardSplitIndexes);
                                checkChannelSettingsArray(channelSettingsArray, names.length);
                                checkChannelSettingsValues(channelSettingsArray);

                                settingsChangePerSection = getSettingsChangePerSect(names, keyboardSplitIndexes, channelSettingsArray);
                            }

                            return settingsChangePerSection;
                        }

                        let settingsSelect = getElem("settingsSelect"),
                            settingsChangePerSection = getSettingsChangePerSection(ResSynth.synthSettingsDefs);

                        console.assert(settingsChangePerSection.length < 127);

                        for(let sectionIndex = 0; sectionIndex < settingsChangePerSection.length; sectionIndex++)
                        {
                            let option = new Option();

                            option.innerHTML = settingsChangePerSection[sectionIndex].name;
                            settingsSelect.options.add(option);
                        }

                        settingsSelect.settingsChangePerSection = settingsChangePerSection;
                        settingsSelect.selectedIndex = 0;
                        settingsSelect.previousIndex = Number.MAX_VALUE;
                    }
                    function setRecordingDiv()
                    {
                        let recordingSelect = getElem("recordingSelect"),
                            playRecordingButtonInput = getElem("playRecordingButtonInput");

                        // recordings is a global array (has been retrieved from recordings.js)
                        if(presetRecordings.length > 0)
                        {
                            for(let i = 0; i < presetRecordings.length; i++)
                            {
                                let option = new Option();
                                option.innerHTML = presetRecordings[i].name;
                                recordingSelect.options.add(option);
                            }
                            recordingSelect.disabled = false;
                            playRecordingButtonInput.disabled = false;
                        }
                        else
                        {
                            let option = new Option();
                            option.innerHTML = "no recordings have been defined (see docs)";
                            recordingSelect.options.add(option);
                            recordingSelect.disabled = true;
                            playRecordingButtonInput.disabled = true;
                        }

                        recordingSelect.selectedIndex = 0;
                    }

                    setPresetSettingsDiv();
                    setChannelPressureDiv();                    
                    setKeyboardSplitDiv();
                    setRecordingDiv();
                }

                function displayAllPage2Divs()
                {
                    getElem("synthSettingsDiv").style.display = "block";
                    getElem("hostSettingsDiv").style.display = "block";

                    setPerformanceGUIState1();
                }

                let
                    bankSelect = getElem("bankSelect"),
                    presetSelect = getElem("presetSelect"),
                    mixtureSelect = getElem("mixtureSelect"),
                    tuningGroupSelect = getElem("tuningGroupSelect");

                console.assert(synth.name === "ResidentSynth", "Error: this application only uses the ResidentSynth");

                setChannelsDiv();

                setBankSelect(bankSelect);
                setPresetSelect(presetSelect, bankSelect);
                setMixtureSelect(mixtureSelect);

                setTuningGroupSelect(tuningGroupSelect);
                setTuningSelect();
                setSemitonesAndCentsControls();

                setCommandsAndControlsDivs();
                setOrnamentsDiv();

                setHostSettingsDiv();

                onSettingsSelectChanged();

                displayAllPage2Divs();
            }

            getElem("continueAtStartButtonDiv").style.display = "none";

            setInputDeviceEventListener(getElem("inputDeviceSelect"));

            // Its important to do the following _after_ user interaction with the GUI.
            synth.close()
                .then(() =>
                {
                    console.log("Closed ResidentSynth");
                    synth.open()
                        .then(() =>
                        {
                            console.log("Opened ResidentSynth");
                            // This function initializes the synth with the (default) values of all the host's controls
                            // by calling the corresponding functions in the synth's public interface.
                            setPage2Display(synth);
                        })
                        .catch(() => {console.error("Error opening ResidentSynth");});
                })
                .catch(() => {console.error("Error closing ResidentSynth");});
        },

        // exported
        noteCheckboxClicked = function()
        {
            var
                note1Checkbox = getElem("sendNote1Checkbox"),
                note2Checkbox = getElem("sendNote2Checkbox");

            if((!note1Checkbox.checked) && (!note2Checkbox.checked))
            {
                note2Checkbox.checked = true;
            }
        },

        // exported
        doNotesOn = function()
        {
            function sendNoteOn(key, velocity)
            {
                let msg = new Uint8Array([ResSynth.constants.COMMAND.NOTE_ON + currentChannel, key, velocity]);
                sendMessage(msg, currentChannel);
            }

            let
                note1Checkbox = getElem("sendNote1Checkbox"),
                note1Index = getElem("notesDivIndexInput1").valueAsNumber,
                note1Velocity = getElem("notesDivVelocityInput1").valueAsNumber,
                note2Checkbox = getElem("sendNote2Checkbox"),
                note2Index = getElem("notesDivIndexInput2").valueAsNumber,
                note2Velocity = getElem("notesDivVelocityInput2").valueAsNumber,
                holdCheckbox = getElem("holdCheckbox"),
                sendButtonInput = getElem("sendButtonInput");

            if(holdCheckbox.checked === true)
            {
                sendButtonInput.disabled = true;
            }

            if(note1Checkbox.checked)
            {
                sendNoteOn(note1Index, note1Velocity);
            }
            if(note2Checkbox.checked)
            {
                sendNoteOn(note2Index, note2Velocity);
            }
        },

        // exported
        doNotesOff = function()
        {
            function sendNoteOff(noteIndex, noteVelocity)
            {
                var
                    NOTE_ON = ResSynth.constants.COMMAND.NOTE_ON,
                    NOTE_OFF = ResSynth.constants.COMMAND.NOTE_OFF;

                if(synth.commands.indexOf(NOTE_OFF) >= 0)
                {
                    let msg = new Uint8Array([ResSynth.constants.COMMAND.NOTE_OFF + currentChannel, noteIndex, noteVelocity]);
                    sendMessage(msg, currentChannel);
                }
                else
                {
                    let msg = new Uint8Array([ResSynth.constants.COMMAND.NOTE_ON + currentChannel, noteIndex, 0]);
                    sendMessage(msg, currentChannel);
                }
            }

            var
                note1Checkbox = getElem("sendNote1Checkbox"),
                note1Index = getElem("notesDivIndexInput1").valueAsNumber,
                note1Velocity = getElem("notesDivVelocityInput1").valueAsNumber,
                note2Checkbox = getElem("sendNote2Checkbox"),
                note2Index = getElem("notesDivIndexInput2").valueAsNumber,
                note2Velocity = getElem("notesDivVelocityInput2").valueAsNumber;

            if(note1Checkbox.checked)
            {
                sendNoteOff(note1Index, note1Velocity);
            }
            if(note2Checkbox.checked)
            {
                sendNoteOff(note2Index, note2Velocity);
            }
        },

        // exported
        holdCheckboxClicked = function()
        {
            let holdCheckbox = getElem("holdCheckbox");

            doNotesOff();

            if(holdCheckbox.checked === false)
            {
                getElem("sendButtonInput").disabled = false;
            }
        },

        init = function()
        {
            function setupInputDevice()
            {
                function setInputDeviceSelect(midiAccess)
                {
                    function setInitialDivsDisplay() { 
                        getElem("loadingMsgDiv").style.display = "none";
                        getElem("synthSettingsDiv").style.display = "none";
                        getElem("hostSettingsDiv").style.display = "none";
                        getElem("continueAtStartButtonDiv").style.display = "block";
                    }

                    let iDevSelect = getElem("inputDeviceSelect"),
                        option;

                    if(iDevSelect.options.length > 0) // length is 0 when loading
                    {   // important when called by midiAccess.onstatechange
                        iDevSelect.options.length = 0;
                    }  

                    option = document.createElement("option");
                    //  21.06.2024 replace if(midiAccess !== null) by if((midiAccess !== null) && (midiAccess.inputs.size > 0) 
                    if((midiAccess !== null) && (midiAccess.inputs.size > 0))
                    {
                        midiAccess.inputs.forEach(function(port)
                        {
                            //console.log('input id:', port.id, ' input name:', port.name);
                            option = document.createElement("option");
                            option.inputDevice = port;
                            option.text = port.name;
                            iDevSelect.add(option, null);
                        });
                        iDevSelect.disabled = false;
                    }
                    else
                    {
                        option.text = "No MIDI input devices";
                        iDevSelect.add(option, null);
                        iDevSelect.disabled = true;
                    }

                    iDevSelect.selectedIndex = iDevSelect.options.length - 1;
                    inputDevice = iDevSelect[iDevSelect.selectedIndex].inputDevice;

                    setInitialDivsDisplay();
                }

                function onSuccessCallback(midiAccess)
                {
                    // Add the midiAccess.inputs to the inputDeviceSelect.
                    setInputDeviceSelect(midiAccess);
                }

                // This function will be called either
                // if the browser does not support the Web MIDI API,
                // or if the user refuses permission to use his hardware MIDI devices.
                function onErrorCallback()
                {
                    alert("Error getting midiAccess for the inputDevice.");
                }

                navigator.requestMIDIAccess().then(onSuccessCallback, onErrorCallback);
            }

            async function setAudioDeviceSelect()
            {
                const permission = await navigator.permissions.query({name: "microphone"});
                if(permission.state == "prompt")
                {
                    alert("More audio outputs are available when user grants access to the microphone");
                    const stream = await navigator.mediaDevices.getUserMedia({audio: true});
                    stream.getTracks().forEach((track) => track.stop());
                }

                const devices = await navigator.mediaDevices.enumerateDevices();
                const AudioOutputDevices = devices.filter(device => device.kind == "audiooutput");

                let audioDeviceSelect = getElem("audioDeviceSelect");
                for(let i = 0; i < AudioOutputDevices.length; i++)  
                {
                    let audioDev = AudioOutputDevices[i]
                    let option = document.createElement("option");
                    option.text = audioDev.label;
                    option.deviceId = audioDev.deviceId;
                    audioDeviceSelect.add(option, null);
                }
            }

            function getChannelPerKeyArrays()
            {
                // See comments in keyboardSplitDefs.js and ornamentDefs.js.
                // Further checking is done in setPrivateChannelPerKeyArrays() and setPrivateOrnamentPerKeyArrays().
                // Throws an exception if an error is found in the keyboardSplitDefs.
                function checkKeyValuesStrings(keyValuesStringsArray)
                {
                    // A RegExp for checking that a string contains zero or more "intVal1:intVal2;" strings separated by whitespace.
                    // Both intVal1 and intVal2 must be in range 0..127. The final ";" is optional.
                    const longInputStringRegex = new RegExp('^((\\d{1,2}|(1[0-1]\\d|12[0-7])):(\\d{1,2}|(1[0-1]\\d|12[0-7])); ?)*((\\d{1,2}|(1[0-1]\\d|12[0-7])):(\\d{1,2}|(1[0-1]\\d|12[0-7]));? ?)?$');

                    // channelPerKeyArrays[0] is allocated automatically. Indices 1..127 are then allocated from keyboardSplitDefs.js.
                    // The index in channelPerKeyArrays is sent as part of the SET_KEYBOARD_SPLIT_ARRAY midi message, so cant be greater than 127.
                    if(keyValuesStringsArray.length > 126)
                    {
                        throw `keyboardSplitDefs.js: There may not be more than 126 keyboardSplit definition strings in the array.`;
                    }
                    else
                    {
                        for(let i = 0; i < keyValuesStringsArray.length; i++) 
                        {
                            let keyValuesString = keyValuesStringsArray[i];

                            if(keyValuesString.length === 0)
                            {
                                throw `Illegal zero-length keyboardSplitString.: Definition index: ${i}`;
                            }

                            if(longInputStringRegex.test(keyValuesString) === false)
                            {
                                throw `Illegal keyboardSplitString: ${keyValuesString}\nDefinition index: ${i}`;
                            }
                        }
                    }
                }

                // Returns an array of 128 channel indices, one per key index.
                // Throws an exception if keys are not unique and in ascending order, or a channel or key is out of range.
                // 01.09.2023: Interestingly, this function was partly optimized in a dialog with ChatGPT.
                // ChatGPT uses some constructs that I should adopt: (const etc.)
                function getChannelPerKeyArray(keyboardSplitDefs, defIndex)
                {
                    function check(keyChannelPairs, keyValuesString) 
                    {
                        if(keyChannelPairs[0].key !== 0)
                        {
                            const errorString = `Illegal keyboardSplitString: the first key in the string must be 0`;
                            alert(errorString);
                            throw errorString;
                        }

                        for(let i = 0, previousKey = -1; i < keyChannelPairs.length; i++)
                        {
                            let kvp = keyChannelPairs[i],
                                key = kvp.key,
                                channel = kvp.value;

                            if(key <= previousKey || channel < 0 || channel > 15 || key < 0 || key > 127)
                            {
                                const errorString = `Illegal keyboardSplitString: ${keyValuesString}\n<key:channel> component index: ${i}`;
                                alert(errorString);
                                throw errorString;
                            }

                            previousKey = key;
                        }
                    }

                    const keyboardSplitDef = keyboardSplitDefs[defIndex],
                        arraySize = 128,
                        keyChannelPairs = getKeyIntValuePairs(keyboardSplitDef),
                        channelPerKeyArray = (keyChannelPairs.length > 0) ? Array(arraySize).fill(0) : [];

                    check(keyChannelPairs, keyboardSplitDef);

                    for(let i = 0; i < keyChannelPairs.length; i++)
                    {
                        let kvp = keyChannelPairs[i],
                            key = kvp.key,
                            channel = kvp.value,
                            nextKey = (i < keyChannelPairs.length - 1) ? keyChannelPairs[i + 1].key : arraySize;

                        for(let j = key; j < nextKey; j++)
                        {
                            channelPerKeyArray[j] = channel;
                        }
                    }

                    return channelPerKeyArray;
                }

                function getKeyIntValuePairs(keyValuesString)
                {
                    console.assert(keyValuesString.length > 0);

                    const keyValuePairs = [],
                        components = keyValuesString.split(";");

                    for(const component of components)
                    {
                        const [keyStr, valueStr] = component.trim().split(":");
                        const key = parseInt(keyStr);
                        const value = parseInt(valueStr);

                        keyValuePairs.push({key, value});
                    }

                    return keyValuePairs;
                }

                let keyboardSplitDefs = ResSynth.keyboardSplitDefs;

                channelPerKeyArrays.push([]); // an empty array means use the incoming message channel (channelPerKeyArrays[0] always has this value.)

                if(keyboardSplitDefs !== undefined)
                {
                    try
                    {
                        checkKeyValuesStrings(keyboardSplitDefs);

                        for(var i = 0; i < keyboardSplitDefs.length; i++)
                        {
                            let channelPerKeyArray = getChannelPerKeyArray(keyboardSplitDefs, i);  // can return an empty array (meaning use the incoming message channel)
                            channelPerKeyArrays.push(channelPerKeyArray);
                        }
                    }
                    catch(msg)
                    {
                        msg = "Error in keyboardSplitDefs.js\n" + msg;
                        channelPerKeyArrays.length = 0;
                        channelPerKeyArrays.push([]);
                        console.assert(false, msg);
                    }
                }
            }

            // returns an array of recordings
            // Each recording object has three attributes:
            //   name -- the recording's name
            //   settingsArray: an array of channelSettings, each of which contains the initial control channelSettings for a channel in the recording
            //   messages: an array of msg objects, each of which has two attributes
            //     1) msg: a UintArray of the form[status, data1, data2] and
            //     2) delay: an integer, the number of milliseconds to delay before sending the msg.
            function getRecordings()	
            {
                function getMessageData(msgStringsArray)
                {
                    let msgData = [];
                    for(let i = 0; i < msgStringsArray.length; i++)
                    {
                        let msgStr = msgStringsArray[i],
                            strData = msgStr.split(","),
                            status = parseInt(strData[0]),
                            data1 = parseInt(strData[1]),
                            data2 = parseInt(strData[2]),
                            msPositionReRecording = parseInt(strData[3]),
                            msg = new Uint8Array([status, data1, data2]),
                            msgObj = {};

                        msgObj.msg = msg;
                        msgObj.msPositionReRecording = msPositionReRecording;

                        msgData.push(msgObj);
                    }
                    return msgData;
                }

                let wRecordings = ResSynth.recordings,
                    returnRecordings = [];

                if(wRecordings !== undefined)
                {
                    for(let i = 0; i < wRecordings.length; i++)
                    {
                        let record = wRecordings[i],
                            recording = {};

                        recording.name = record.name;
                        recording.channels = record.channels;
                        for(let channelIndex = 0; channelIndex < recording.channels.length; channelIndex++)
                        {
                            recording.channels[channelIndex].messages = getMessageData(recording.channels[channelIndex].messages);
                        }

                        returnRecordings.push(recording);
                    }
                }

                return returnRecordings;
            }

            setAudioDeviceSelect();
            setupInputDevice();

            document.addEventListener('keydown', onQuertyKeyDown);

            getChannelPerKeyArrays(); // loads channelPerKeyArrays using ResSynth.keyboardSplitDefs from keyboardSplitDefs.js
            presetRecordings = getRecordings();  // loads definitions from recordings.js.
            synth = new ResSynth.residentSynth.ResidentSynth(); // loads definitions from files in residentSynth/config.
        },

        publicAPI =
        {
            onInputDeviceSelectChanged: onInputDeviceSelectChanged,
            onAudioDeviceSelectChanged: onAudioDeviceSelectChanged,

            onContinueAtStartClicked: onContinueAtStartClicked,

            webAudioFontWebsiteButtonClick: webAudioFontWebsiteButtonClick,

            onChannelSelectChanged: onChannelSelectChanged,

            onBankSelectChanged: onBankSelectChanged,
            onPresetSelectChanged: onPresetSelectChanged,
            onMixtureSelectChanged: onMixtureSelectChanged,
            onTuningGroupSelectChanged: onTuningGroupSelectChanged,
            onTuningSelectChanged: onTuningSelectChanged,
            onSemitonesOffsetNumberInputChanged: onSemitonesOffsetNumberInputChanged,
            onCentsOffsetNumberInputChanged: onCentsOffsetNumberInputChanged,

            onSettingsSelectChanged: onSettingsSelectChanged,
            onExportSettingsButtonClicked: onExportSettingsButtonClicked,

            onplayRecordingButtonInputClicked: onplayRecordingButtonInputClicked,
            oncancelPlaybackButtonInputClicked: oncancelPlaybackButtonInputClicked,
            onstartRecordingButtonInputClicked: onstartRecordingButtonInputClicked,
            onstopRecordingButtonInputClicked: onstopRecordingButtonInputClicked,
            onsaveRecordingButtonInputClicked: onsaveRecordingButtonInputClicked,
            ondiscardRecordingButtonInputClicked: ondiscardRecordingButtonInputClicked,

            onKeyOrnamentsSelectChanged: onOrnamentsSelectChanged,

            onKeyboardSplitSelectChanged: onKeyboardSplitSelectChanged,
            onChannelPressureSelectChanged, onChannelPressureSelectChanged,

            noteCheckboxClicked: noteCheckboxClicked,
            holdCheckboxClicked: holdCheckboxClicked,

            doNotesOn: doNotesOn,
            doNotesOff: doNotesOff
        };
    // end var

    init();

    return publicAPI;

}(document));
